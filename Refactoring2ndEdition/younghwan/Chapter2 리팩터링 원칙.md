## CHAPTER 02 리팩터링 원칙

### 토론

켄트 벡이 “난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요” 라는 말을 했습니다. 리팩터링 관점에서 뛰어난 습관에는 어떤 것들이 있을까요??

### 2.1 리팩터링 정의

리팩터링 : [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

리팩터링(하다) : [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

- 리팩터링 하기 전과 후의 코드는 똑같이 동작해야 한다
- 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다

→ !?!?!?!?!?!? 리팩터링의 시간이 오래 걸리는 이유 중 하나였는데 충격이네요

- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.

### 2.2 두 개의 모자

1. 기능 추가 모자
2. 리팩터링 모자

내가 지금 쓰고있는 모자가 무엇인지, 그에 따른 작업 방식의 차이가 무엇인지 인식해야 한다

→ 하나의 이슈를 처리하며 모자를 번갈아 가며 쓸 일이 있을까요??

### 2.3 리팩터링하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다
- 리팩터링하면 버그를 쉽게 찾을 수 있다

> 난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요

→ 멋져..!!

- 리팩터링하면 프로그래밍 속도를 높일 수 있다

### 2.4 언제 리팩터링해야 할까?

3의 법칙

1. 처음에는 그냥 한다
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

- 코드베이스에 기능을 새로 추가하기 직전

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**

- 코드를 분석할 때 이해를 위한 리팩터링을 한다면, 깊은 수준까지 이해하게 된다

**쓰레기 줍기 리팩터링**

- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.

**계획된 리팩터링과 수시로 하는 리팩터링**

- 보기 싫은 코드를 발견하면 리팩터링하자
- 수정하기 쉽게 정돈하자
- 계획된 리팩터링은 최소화하고 수시로 하자

**오래 걸리는 리팩터링**

- 오래 걸리는 리팩터링에는 회의적이다
- 조금씩 해결해가는 편이 효과적일 때가 많다

**코드 리뷰에 리팩터링 활용하기**

- 코드 리뷰에 리팩터링을 접목하면 좋다.
- PR 리뷰보다 코드 작성자가 참석해서 맥락을 설명해줄 수 있는 것이 좋다.

→ 코드 작성자가 참여하는 코드 리뷰는 시간이 엄청 오래걸리고 비효율 적일 것 같은데, 어떻게 생각하시나요??

**리팩터링하지 말아야 할 때**

- 굳이 수정할 필요가 없다면 리팩터링하지 않는다
- 내부 동작을 이해해야 할 시점에 리팩터링한다
- 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다

→ 2.4 언제 리팩터링 해야할까? 부분 정리하면서 느낀건데, 리팩터링을 어려운 디자인 패턴을 적용하거나 대단한 구조개선을 하는 것이라는 착각을 하고있던 것 같습니다.

### 2.5 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하**

리팩터링은 오직 경제적인 이유로 하는 것이다.

- 개발 시간을 단축한다.
- 기능 추가 시간을 줄인다.
- 버그 수정 시간을 줄인다.

**코드 소유권**

→ 딱히 저에게는 해당하지 않는 내용인 것 같네요

**브랜치**

→ 브랜치를 사용하여 기능 개발을 하고있긴 하지만 브랜치 통합 주기가 짧아 잘 하고 있는 것 같습니다.

**테스팅**

- 테스트 스위트가 필요하다
- 자가 테스트 코드를 마련해야 한다

**레거시 코드**

- 레거시 코드를 리팩터링 하려면? 테스트 보강!

**데이터베이스**

### 2.6 리팩터링, 아키텍처, 애그니

리팩터링은 아키텍처를 바꿀 수 없다는 관점을 바꾸었다.

요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다.

간결한 설계, 점진적 설계, 애그니(you are not going to need it)

### 2.7 리팩터링과 소프트웨어 개발 프로세스

XP, TDD, 애자일 방법론

테스트 코드, 지속적 통합, 리팩터링은 서로 강력한 상승효과를 발휘한다.

### 2.8 리팩터링과 성능

‘직관적인 설계 vs 성능’

- 성능 보다는 직관적인 설계가 우선이다.
- 리팩터링 하면 소프트웨어가 느려질 수 있지만 성능을 튜닝하기는 더 쉬워진다.

프로그래머가 높은 성능을 유지하기 위해 하는 일들의 효과는 변변치 않다.

- 프로그램이 다루기 어려운 형태로 변하기 쉽다
- 컴파일러, 런타임, 하드웨어의 이해 없이 작성될 때가 많다

→ 뜨끔. 섣불리 추측하지 말고 성능을 측정해보자.

- 대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다

### 2.9 리팩터링의 유래

→ 리팩터링이라는 말이 없는 세상이 있었다는 생각을 못해봤네요. 지금 와서는 당연한 기법중에 하나가 되었지만 만들어지는 과정이 흥미로웠습니다.

### 2.10 리팩터링 자동화

→ IntelliJ 에서 Refactor 기능을 자주 이용합니다. 세상 많이 좋아진듯

### 2.11 더 알고 싶다면

윌리엄 웨이크 “리팩터링 워크북”

조슈아 케리에프스키 “패턴을 활용한 리팩터링”

스캇 앰블러, 프라모드 사달게 “리팩토링 데이터베이스”

마이클 페더스 “레거시 코드 활용 전략”