## CHAPTER 02 Principles in Refactoring

## Discussions

책에서는 리팩터링을 거의 수시로 생각날때, 기능 추가할 때, 기능 추가하기 전에 등등의 이유로
당장 빠르게 하라고 합니다.

혹시 리팩터링을 별도의 활동으로 생각하고 계시고, 시간을 따로 내서 하시는 분이 있다면
왜 그렇게 생각하는지 함께 얘기해 보면 좋을 것 같습니다.

저는 물론 리팩터링 하는 시간을 따로(스토리 혹은 몰래 야근하면서) 내서 하지 않습니다!

### 2.1 DEFINING REFACTORING

명사로 쓸 때,

> _리팩터링: [명사] 소프트웨어의 겉보기 동작(observable behavior)은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법_

동사로 쓸 때,

> _리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다._

리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> _누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다._

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 '재구성(restructuring)'이라는 포괄적인 용어로 표현하고,
리팩터링은 재구성 중 특수한 한 형태로 본다.

겉보기 동작(observable behavior)은 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻이다.
함수 추출하기를 거쳐서 성능이 변할 수는 있지만 사용자 관점에서는 달라지는게 없어야 한다.

리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
따라서 프로그램 성능은 좋아질 수도, 나빠질 수도 있다.

### 2.2 THE TWO HATS

기능을 추가할 때는 '기능 모자'를 쓰고 새 기능을 추가한다.
리팩터링 할 때는 '리팩터링 모자'를 쓰고 코드 재구성에만 전념한다.
(앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한) 테스트도 새로 만들지 않는다.
부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.

전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

### 2.3 WHY SHOULD WE REFACTOR?

리팩터링이 소프트웨어의 모든 문제점을 해결해 주지는 않는다.
하지만 코드를 건강한 상태로 유지하는 데 도와준다.

#### Refactoring Improves the Design of Software

리팩터링을 하지 않으면 소프트웨어의 내부 설계(아키텍쳐)가 썩기 쉽다.
코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부폐되는 속도는 더욱 빨라진다.

중복 코드 제거는 설계 개선 작업의 중요한 한 축이다.
중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고, 바람직한 설계의 핵심이다.

#### Refactoring Makes Software Easier to Understand

컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야 한다.
다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸리게 할 수도 있다.

프로그램을 동작시키는 데만 신경쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다.
리팩터링은 코드가 더 잘 읽히게 도와준다.

다른 사람을 배려하기 위해서이기도 하지만, 그 다른 사람이 자기 자신을 때가 많다.

#### Refactoring Helps Me Find Bugs

리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.
그러면 코드가 명확해지고 이해하기 쉬워지는데 여기서 동시에 버그를 찾기도 쉬워진다.

#### Refactoring Helps Me Program Faster

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.
저자는 이 효과를 설계 지구력 가설(Design Stamina Hypothesis)이라고 부른다.
내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

리팩터링을 하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.
처음 부터 좋은 설계를 마련하는 건 어렵다, 그래서 빠른 개발이라는 목표를 달성하려면 리팩터링이 반드시 필요하다.

### 2.4 WHEN SHOULD WE REFACTOR?

돈 로버츠의 3의 법칙

- 처음에는 그냥 한다
- 비슷한 일을 두 번째로 하게 되면(코드 중복을 인식), 일단 계속 진행한다.
- 비슷한 일을 세 번째 하게 되면 리팩터링한다.

#### Preparatory Refactoring—Making It Easier to Add a Feature

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
이 시점에 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.

> _비유하면 지금 위치에서 동쪽으로 100km를 이동하려는데 그 사이를 숲이 가로막고 있다면, 좀 둘러가더라도 20km 북쪽에 있는 고속도로를 타는 편이 세 배나 빠를 수 있다. 다들 "직진!"을 외치더라도, 따로는 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다. - 제시카 커_

준비를 위한 리팩터링(Preparatory refactoring)으로 상황을 개선해 놓으면 버그가 수정된 ㅅ아태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.

#### Comprehension Refactoring: Making Code Easier to Understand

코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있고 동료들도 알 수 있다.

이해를 위한 리팩터링(Comprehension refactoring)을 해서 코드가 깔끔하게 정리되면 전에 보이지 않던 설계가 눈에 들어온다.
랄프 존슨은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기에 비유한다.

#### Litter-Pickup Refactoring

코드를 파악하던 중에 일을 비효율적으로 처리하는 것이 있다면, 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하도록 내버려 두는 것은 좋지 않다.
쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)을 통해 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 하던 일을 끝내고 나서 처리한다.

시간이 오래 걸리고 당장 급한 일을 처리해야 할 수도 있지만, 조금이라도 개선해 두는 것이 좋다.
캠핑 규칙을 적용해서 항상 처음 봤을 때 보다 깔끔하게 정리하고, 조금씩 개선하다 보면 결국 문제가 해결된다.

#### Planned and Opportunistic Refactoring

리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다.
프로그래밍 과정에 자연스럽게 녹인 것이다.

```
의견)
이 부분에서 상당히 동의하는데,
리팩터링을 하기 위해 따로 시간을 내는 것 보다 작업 하면서 잠깐 시간을 내고 리팩터링을 진행하는게 더 좋다는 생각이다.
```

> _보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다._

> _무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자 - 켄트 백_

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다.
소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다.
새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다.

리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

저자는 리팩터링 커밋과 기능 추가 커밋을 분리하는 것에 동의하지 않는다.
리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비다.

```
의견)
여기서도 리팩터링을 구분하지 않고 자연스럽게 진행하는 것에 상당히 동의한다.
리팩터링을 뭔가 다른 시간을 내서 해야 한다는 특별한 활동이라는 생각은 안가지는게 좋다는 입장이다.
```

#### Long-Term Refactoring

팀 전체가 리팩터링에 매달리는 모습은 좋지 않다.
문제를 몇 주에 걸쳐서 조금씩 해결해가는 편이 효과적이다.

#### Refactoring in a Code Review

리팩터링은 다른 사람의 코드를 리뷰하는 데도 도움이 된다.
새로운 아이디어가 떠오르면 리팩터링 하여 쉽게 구현할 수 있는지 살펴보고 쉽다면 바로 리팩터링한다.

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데 도움이 된다.
개선안들을 제시하는 데서 그치지 않고, 바로 구현해 볼 수 있기 때문이다.

코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 pull request 보다는 pair programming이 더 좋다.
코드 작성자가 직접 맥락을 설명해 줘야 리뷰어도 변경 의도를 제대로 이해할 수 있기 때문이다.

#### What Do I Tell My Manager?

기술을 모르는 관리자와 고객에게는 리팩터링 한다고 말 안하는게 낫다.
일정을 우선으로 여기는 관리자는 일을 빨리 끝내는 방향으로 진행하기를 원하기 때문에
구체적인 방법은 개발자가 판단해야 한다.
프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.

#### When Should I Not Refactor?

굳이 수정할 필요가 없다고 판단이 되면 리팩터링 하지 않는다.
내부 동작을 이해하지 못한채로 코드가 지저분하다는 이유로도 하지 않는다.
리팩터링 하는 것 보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링 하지 않는다.

하지만, 직접 리팩터링 해 보기 전에는 어느 쪽이 쉬운지 확신할 수 없으므로
뛰어난 판단력과 경험이 뒷받침 되어야 한다.

### 2.5 PROBLEMS WITH REFACTORING

#### Slowing Down New Features

> _리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다_

리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황이라면
프로 개발자로서 가진 경험을 잘 발휘해서 결정한다.

개발 속도 저하를 이유로 리팩터링을 금지하는 문화도 있지만, 개발자 스스로 그렇게 생각하는 경향이 있다.
개발팀에 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 한다.

사람들이 빠지기 쉬운 가장 위험한 오류는
리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관' 처럼 도덕적인 이유로 정당화하는 것이다.
리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는게 아니라 경제적인 이유로 하는 것이다.

#### Code Ownership

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.
리팩터링을 할 수 있지만, 제약이 따른다.

저자의 입장은 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장이다.
저자가 선호하는 방식은 코드 소유권을 팀에 두는 것이다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다.

#### Branches

브랜치를 자주 통합해서 다른 브랜치와 차이가 크게 벌어지는 것을 줄이고 머지하는데 복잡도를 낮추는 방향으로 진행한다.
지속적 통합(CI) 방식으로 하면 머지 복잡도를 줄일 수 있을 뿐 아니라 리팩터링과 궁합이 잘 맞다.
CI와 리팩터링을 합쳐서 익스트림 프로그래밍(eXtreme Programming, XP)을 만들었다.

#### Testing

리팩터링을 하고 오류를 빨리 잡기 위해 코드를 테스트 하는 자가 테스트 코드(self-testing code)를 진행해야 한다.
자가 테스트는 테스트에 어느 정도 노력을 기울여야 하지만, 효과는 상당하다.
자가 테스트는 리팩터링을 할 수 있게 해주고 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.

#### Legacy Code

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다.
하지만 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

레거시 코드에 테스트를 추가하면 좋긴 하지만,
보통 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트 할 수 있다.

<레거시 코드 활용 전략>에 나온 지침대로, '프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다'가 주된 내용이다.

테스트 코드가 있어도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다.

#### Databases

진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법을 통해 데이터베이스도 리팩터링이 가능한 영역이다.

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.
이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다.

### 2.6 REFACTORING, ARCHITECTURE, AND YAGNI

리팩터링은 일단 코드로 작성된 뒤로는 아키텍쳐를 바꿀 수 없다는 관점을 크게 바꾸어 놓았다.
리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.
변경에 유연하게 대처할 수 있는 유연성 메커니즘(flexibility mechanism)을 소프트웨어에 심어두고 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다.

리팩터링을 활용하면, 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다.
진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.

간결한 설계(simple design), 점진적 설계(incremental design), YAGNI(you aren't going to need it)를 통해 아키텍처와 설계를 개발 프로세스에 녹이는 다른 방식으로 이해해야 한다.

### 2.7 REFACTORING AND THE WIDER SOFTWARE DEVELOPMENT PROCESS

애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.

자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승 효과를 발휘한다.

### 2.8 REFACTORING AND PERFORMANCE

직관적인 설계 vs 성능은 중요한 주제다.
리팩터링을 하면 소프트웨어가 느려질 수도 있는 건 사실이다.
하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.

빠른 소프트웨어를 작성하는 세 가지 경험담

- 시간 예산 분배 방식: 엄격한 시간 엄수를 강조
- 끊임없는 관심
- '90%의 시간은 낭비'

프로그램을 잘 리팩터링 해 두면 성능 최적화에 도움이 된다.
성능 튜닝에 투입할 시간을 벌 수 있다. 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다.
성능을 더 세밀하게 분석할 수 있다. 프로파일러가 지적해주는 코드의 범위가 더 좁아지고 튜닝하기 쉬워진다.

### 2.9 WHERE DID REFACTORING COME FROM?

유래와 상관 없이 실력 있는 프로그래머는 항상 자신의 코드를 정리하는 데 어느 정도의 시간을 할애해왔다.
워드 커닝햄과 켄트 벡은 1980년대 부터 스몰토크로 개발하면서 컴파일-링크-실행 주지가 짧은 좋은 환경이어서 리팩터링을 진행해 왔다. 이런 환경에 특화된 소프트웨어 개발 방법을 고민했고, XP가 탄생하게 됨.
스몰토크 커뮤니티를 주도하던 인물 중에 GoF의 디자인 패턴 저자 중 하나인 UIUC 대학교 교수 랄프 존슨이 프레임워크로 소프트웨어를 개발하는 것에 관심이 많았는데 효율적이고 유연한 프레임워크를 개발하는데 리팩터링이 어떻게 기여하는지를 연구했다.

랄프의 박사 과정 학생인 빌 옵다이크가 의미 보존(semantic-preserving) 리팩터링 기법들을 연구해서 발표했다.

1992년 OOPSLA 컨퍼런스에서 존 브랜트와 돈 로버츠는 빌의 리팩터링 도구 아이디어를 훨씬 발전시켜서 스몰토크 환경을 위한 최초의 리팩터링 도구인 <리팩터링 브라우저>를 개발했다.

켄트 벡과 함께 프로젝트를 진행하고 함께 리팩터링을 하면서 중요한 기법이라는 것을 깨닫고 리팩터링 책의 초판을 쓰게 되었다.

하지만 대중화되면서 코드를 재구성하는 모든 작업을 가리키는 느슨한 의미로 사용하는 사람이 많아졌다.
어쨌든 리팩터링은 주류 개발 기법으로 자리 잡았다.

### 2.10 AUTOMATED REFACTORINGS

인텔리제이 IDEA나 이클립스에서 자바로 프로그래밍을 하면 자동 리팩터링 기능이 지원된다.
현재는 에디터나 독립 도구에서도 리팩터링 기능을 제공할 정도로 자동 리팩터링이 흔해졌다.

리팩터링을 자동화하는 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다.

자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리(syntax tree)로 해석해서 다뤄야 한다.
뛰어난 IDE가 자동 리팩터링도 더 풍부하게 제공한다. 코드 탐색과 린팅(linting)을 비롯해 다양한 기능을 구현하는데 구문 트리를 이용한다.

대부분의 자동 리팩터링이 믿을만하더라도 중간에 꼬인 부분이 없는지 테스트로 확인하는 것이 바람직하다.

### 2.11 GOING FURTHER

리팩터링 연습에 주력한 책을 원한다면 윌리엄 웨이크가 쓴 <[리팩터링 워크북](http://aladin.kr/p/FFHAz)>을 추천한다.

```
의견)
리팩터링 워크북도 오래된 책이어서 아쉽게 절판되었다.
하지만!
중고 판매자가 팔고 있는 책이 딱 한권 있어서 바로 구매했다! 야호!
```

특정 분야에 특화된 리팩터링 책으로 스캇 엠블러와 프라모드 사달게의 <[리팩토링 데이터베이스](http://aladin.kr/p/9F99b)>와 엘리엇 러스티 해롤드의 <[리팩토링 HTML](http://aladin.kr/p/tFymf)>이 있다.

마이클 페더스의 <[레거시 코드 활용 전략](http://aladin.kr/p/yLXnX)>이 있다. 주로 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링 하는 방법을 다룬다.

특정 언어에 특화된 리팩터링을 설명하는 책으로 제이 필즈와 셰인 하비의 <Refactoring: Ruby Edition>이 있다.