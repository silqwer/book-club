## CHAPTER 01 Refactoring: A First Example

## Discussions

사실 코드 예제를 통해 리팩토링 하는 방법을 설명하는 부분이라 논의 내용이 없을 법도 하지만
하나 인상적이었던 것 중 하나가 작은 단위로 compile, test, commit 하는 걸 꽤나 강조합니다.

이렇게 작은 단위로 작업을 습관화 해서 리팩터링 까지 한 부분이 있다면
저자가 자랑하는 것 말고 자랑해 볼 수 있을 것 같습니다.

우선 저는 리팩터링을 수시로 하는 편이고 기능 구현 중에도 리팩터링을 잘 끼워 넣어서 하는 편이기도 합니다.
최근에 작업했던 예제를 보여드릴 수 있을 것 같아요.

### 1.1 THE STARTING POINT

공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정
장르는 비극과 희극
공연료와 별개로 포인트(volume credit)를 지급해서 다음번 의뢰 시 공연료를 할인받을 수도 있다.

```
의견)
코드 예시는 그냥 평범한 듯
이 짧은 메서드로 리팩토링이 얼마나 진행되는지 확인해 보는 것도 좋을 것 같다는 생각이 든다.
```

### 1.2 COMMENTS ON THE STARTING PROGRAM

프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

> _프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링 하고 나서 원하는 기능을 추가한다._

로직을 변경할 일이 절대 없다면 복사해서 붙이는 방식도 상관없지만,
오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.

새로운 요구사항이 만들어지면 공연료와 적립 포인트 계산 법은 어떻게든 변경하게 되어 있다.

다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 한다.

### 1.3 THE FIRST STEP IN REFACTORING

리팩터링의 첫 단계는 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들 부터 마련한다.
리팩터링에서 테스트의 역할은 굉장이 중요하다.

테스트 결과를 보고하는 방식은 성공/실패를 스스로 판단하는 자가진단 테스트로 만든다.

> _리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다._

```
의견)
지금은 unit test 자체가 framework로 되어 있고 자동화 되어 있는데
그렇지 못한 테스트를 하는 경우가 있어서 뭔가 강조한 느낌이 많이 든다.
```

### 1.4 DECOMPOSING THE STATEMENT FUNCTION

중간의 switch문의 공연 요금 계산 부분
함수 추출하기 방법
함수 이름은 amountFor로 하고 perf, play 변수를 파라미터로 받는다

``` javascript
function amountFor(perf, play) { // 값이 바뀌지 않는 변수는 매개변수로 전달
    let thisAmount = 0; // 변수를 초기화 하는 코드
    ...
}
```

아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트 하는 습관을 들이는 것이 좋다.
한가지를 수정할 때마다 테스트하면, 오류가 생겨도 변경 폭이 작기 때문에 문제를 찾고 해결하기가 훨씬 쉽다.
조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 좋다.

> _리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

수정 사항을 테스트하고 문제 없으면 commit을 진행하고 작은 단위의 변경들이 의미 있는 단위로 뭉쳐지면  push를 진행한다.

매개변수의 이름에 타입 이름을 적는 형태는 저자의 코딩 스타일이다. 어쨌든 의미 있는 변수 이름으로 변경해 주는 것도 중요하다.

켄트 벡의 < Smalltalk Best Practice Patterns(Addison-Wesley, 1997) > 에서 좋은 팁 하나 추가

> _컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

```
의견)
이렇게 중요하고 어렵지 않은 좋은 팁을 잘 못지키는 이유가 뭔지 조금 생각해 봤는데
그건 아마 동작하는 코드라면 그 다음은 생각하고 싶지 않아서일 것이라는 내 개인적인 생각이 강하다.
따라서 여기 나오는 예시 중에 amountFor() 함수를 리팩터링 한 이후에 의미 있는 변수 이름으로 변경한 리팩터링이 사실 더 의미있는 리팩터링이라고 생각한다.
```

**play 변수 제거하기**

임시 변수를 질의 함수로 바꾸기(7.4절)를 통해서 play와 같은 임시로 만든 로컬 변수들을 최대한 제거한다.

``` javascript
function playFor(aPerformance) {
    return plays[aPerformance.playID];
}
...
const play = playFor(perf);  // 우변을 함수로 추출
let thisAmount = amountFor(perf, play);
```
컴파일-테스트-커밋을 진행 후
변수 인라인 하기를 적용해서 로컬 변수를 제거하고 바로 함수 호출의 결과를 파라미터로 넘겨준다

``` javascript
let thisAmount = amountFor(perf, playFor(perf));
```

지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다.

**적립 포인트 계산 코드 추출하기**

volumeCreditsFor() 함수를 새로 추출하고 for 반복문을 돌면서 계산 결과 값을 누적한다.

**format 변수 제거하기**

format() 함수를 추출해서 USD 통화 형태로 만들어 준다. 함수 이름도 formatAsUSD 보다는 usd로 변경한다.

이름 짓기는 중요하면서도 쉽지 않은 작업이다. 
처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다.

**volumeCredits 변수 제거하기**

반복문 쪼개기로 volumeCredits 값이 누적되는 부분을 따로 빼낸다.

반복문을 쪼개서 성능이 느려지지 않는지에 대한 걱정을 할 수 있지만, 코드의 실제 성능을 정확히 예측하기는 어렵다.
하지만 때로는 리팩터링이 성능에 상당한 영향을 주기도 하지만, 저자는 개의치 않고 진행한다.

리팩터링으로 인한 성능 문제는 '특별한 경우가 아니라면 일단 무시하자'
리팩터링으로 인해 성능이 떨어진다면 리팩터링을 마무리 하고 나서 성능 개선을 한다

여태까지 진행한 리팩터링의 네 단계

- 반복문 쪼개기: 변수 값을 누적시키는 부분을 분리한다
- 문장 슬라이드 하기: 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다
- 함수 추출하기: 적립 포인트 계산 부분을 별도 함수로 추출한다
- 변수 인라인하기: volumeCredits 변수 제거

상황이 복잡해 지면 단계를 더 작게 나눈다

### 1.5 STATUS: LOTS OF NESTED FUNCTIONS

최상위 statement 함수는 일곱 줄로 읽을 수 있게 됨
계산 로직은 여러 개의 보조 함수로 분리

### 1.6 SPLITTING THE PHASES OF CALCULATION AND FORMATTING

statement()의 HTML 버전을 만드는 작업: 계산 코드가 분리 됐으므로 최상단 7줄의 HTML 버전만 작성
단계 쪼개기: statement()에 필요한 데이터를 처리하고, 앞서 처리한 결과를 텍스트나 HTML로 표현
함수 추출하기: 청구 내역 출력 코드를 renderPlainText() 함수로 추출
함수로 전달한 데이터를 수정하지 않기 위해 불변 객체를 생

### 1.7 STATUS: SEPARATED INTO TWO FILES (AND PHASES)

코드 라인수는 늘었지만 전체 로직을 구성하는 요소가 뚜렷해지고 계산과 출력 로직이 분리되서 좋아졌다.
프로그래밍에서는 명료함이 진화할 수 있는 소프트웨어의 정수다.

> _캠핑자들에게는 "도착했을 때보다 깔끔하게 정돈하고 떠난다"는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시작 전보다 건강하게(healthy) 만들어 놓고 떠나야 한다._

### 1.8 REORGANIZING THE CALCULATIONS BY TYPE

연극 장르를 추가하고 장르마다 공연료와 적립 포인트 계산법을 다르게 지정하도록 기능을 수정.
객체지향의 핵심 특성인 다형성(polymorphism)을 활용해서 희극 서브클래스와 비극 서브클래스가 각자의 구체적인 계산 로직을 정의.
호출하는 쪽에서 다형성 버전의 공연료 계산 함수를 호출하고, 희극/비극에 따라 정확한 계산 로직을 연결하는 작업 진행
조건부 로직을 다형성으로 바꾸기(10.4절)가 핵심 리팩터링 기법.

#### Creating a Performance Calculator

enrichPerformance()함수는 조건부 로직을 포함하는 amountFor(), volumeCreditsFor()를 호출하여 공연료와 적립 포인트를 계산.
여기서 PerformanceCalculator class를 정의하고 생성, 공연 정보(aPerformance)를 받아 담는 class로 정의

#### Moving Functions into the Calculator

함수를 class로 옮기는 작업이므로 함수 옮기기(8.1절) 리팩터링으로 작업을 단계별로 진행

#### Making the Performance Calculator Polymorphic

class에 로직을 담은 후에 다형성을 지원하도록 서브클래스를 만든다. (타입 코드를 서브클래스로 바꾸기(12.6절))
생성자를 팩터리 함수로 바꾸기(11.8절)를 통해 비극/희극 정보에 따라 각 타입에 맞는 계산기 클래스를 생성해서 리턴해 준다.

### 1.9 STATUS: CREATING THE DATA WITH THE POLYMORPHIC CALCULATOR

연극 장르별 계산 코드를 묶어 놓음. 따라서 새로운 장르가 추가되면 서브클래스를 작성하고 createPerformanceCalculator()에 추가해서 해당 장르의 calculator 객체를 생성한다.

### 1.10 FINAL THOUGHTS

함수 추출하기, 변수 인라인하기, 함수 옮기기, 조건부 로직을 다형성으로 바꾸기 등등의 리팩터링 기법 예시

리팩터링은 코드가 하는 일을 파악하는 데서 시작하므로 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행한다.

> _좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'이다.

코드는 명확해야 한다. 코드를 수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다.
코드를 건강하게 관리하려면 프로그래밍 팀의 현재와 이상의 사이에 항상 신경 쓰면서, 이상에 가까워지도록 리팩터링해야 한다.

리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.