## Chapter 3 Bad Smells in Code

리팩터링 적용 방법을 아는 것과 제때 적용할 줄 아는 것은 다르다.
리팩터링을 언제 멈춰야 하는 지를 판단하는 기준은, 숙련된 사람의 직관 만큼 정확한 것은 없다. 인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄을 넘어가면 안좋은 지 등은 각자 경험을 통해 감을 키워야 한다.

### Discussions

여러 리팩터링 기법에 대해 예시를 통해 소개해 주고 있습니다.
사실 각자 생각하는 리팩터링의 기준이 명확하지 않을 수도 있고,
그 기법에 대해서 크게 생각하지 않았던 것도 많이 있을 것 같은데요.

리팩터링을 하기 이전에 자신이 자주 그리고 많이 저질렀던 잘못된 방식을 얘기해 보면 재미있을 것 같습니다.
또 '이게 리팩터링인가? 당연히 해야 하는거고 그래 왔는데?' 라고 했던 부분도 있으면 얘기해 보면 좋겠습니다.

저는 아래와 같은 실수 혹은 잘못을 주로 했던 편이었던 것 같습니다.

- LONG FUNCTION (긴 함수)
- SPECULATIVE GENERALITY(추측성 일반화)
- LARGE CLASS(거대한 클래스)

그리고 생각지도 못하게 거의 무의식적으로 잘 하는 것도 있습니다.

- LOOPS(반복문)
- REFUSED BEQUEST(상속 포기)

### MYSTERIOUS NAME

코드를 명료하게 표현하는데 가장 중요한 요소는 이름이다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확하게 알 수 있도록 엄청나게 신경써서 이름을 지어야 한다.

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기

마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 가능성이 높다.

### DUPLICATED CODE

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

- 한 클래스에 두 메서드가 똑같은 표현식을 사용한다면 함수 추출하기를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾼다
- 코드가 비슷한데 똑같지 않다면 문장 슬라이드 하기로 한 곳에 모아 함수 추출하기가 가능한지 살펴본다.
- 같은 부모로 부터 파생된 서브클래스들에 코드가 중복되어 있다면 메서드 올리기를 적용한다.

### LONG FUNCTION

주석을 달아야 하는 부분도 함수로 만든다.
함수 이름은 동작 방식이 아닌 의도(intention)가 드러나게 짓는다.
원래 코드 보다 길어지더라도 함수로 뽑는다. 함수 이름에 코드의 목적을 드러내야 한다.
무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

- 함수 추출하기, 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 새로운 함수로 만든다
- 임시 변수를 질의 함수로 바꾸기로 임시 변수의 수를 줄인다
- 매개변수 객체 만들기, 객체 통째로 넘기기로 매개변수의 수를 줄인다
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- swtich문을 case문마다 함수 추출하기를 적용, 각 case의 본문을 함수 호출문 하나로 바꾼다.
- 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 조건부 로직을 다형성으로 바꾸기를 적용한다.
- 성격이 다른 두 가지 작업이 섞여 있다면 반복문 쪼개기로 작업을 분리한다.

### LONG PARAMETER LIST

매개변수 목록이 길어지면 이해하기 어려울 때가 많다

- 다른 매개변수에서 값을 얻어올 수 있는 매개변수는 매개 변수를 질의 함수로 바꾸기로 제거
- 데이터 구조에서 값들을 뽑아 각각 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기로 원본 데이터 구조를 그대로 전달
- 매개변수 객체 만들기로 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애준다
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 여러 함수를 클래스로 묶기를 통해 공통 값들을 클래스의 필드로 정의

### GLOBAL DATA

전역 데이터는 코드 베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

- 변수 캡슐화하기

### MUTABLE DATA

데이터를 변경 했을 때 문제가 되는 상황
불변성이 주는 장점이 있으므로 무분별한 데이터 수정에 따른 위험을 줄이는 방법을 사용

- 변수 캡슐화하기
- 변수 쪼개기
- 문장 슬라이드 하기
- 함수 추출하기
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

### DIVERGENT CHANGE(뒤엉킨 변경)

뒤엉킨 변경은 단일 책임 원칙(SRP)를 지키지 않을 때 나타난다. 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때 발생한다.

- 단계 쪼개기
- 함수 옮기기
- 함수 추출하기
- 클래스 추출하기

### SHOTGUN SURGERY

뒤엉킨 변경과 비슷하면서도 정 반대
코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기
- 함수 인라인 하기
- 클래스 인라인 하기

### FEATURE ENVY(기능 편애)

어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때

- 함수 옮기기
- 함수 추출하기 후 함수 옮기기

### DATA CLUMPS(데이터 뭉치)

데이터 항목 서너 개가 여러 곳에서 함께 뭉쳐 다니면 하나로 합쳐 놓는다.

- 클래스 추출하기
- 매개변수 객체 만들기
- 객체 통째로 넘기기

데이터 뭉치 중 하나를 삭제했을 때 나머지 데이터가 의미가 없다면 객체로 묶어준다.

### PRIMITIVE OBSESSION(기본형 집착)

전화번호와 같은 데이터는 기본형인 단순 문자열 집합 보다는 출력 형식을 포함하는 객체로 만들면 좋다

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- 매개변수 객체 만들기

### REPEATED SWITCHES

- 조건부 로직을 다형성으로 바꾸기

똑같은 조건부 로직이 반복적으로 등장하면 조건 하나를 추가할 때 마다 모두 찾아서 바꿔줘야 하므로 다형성을 사용하면 좋다

### LOOPS

- 반복문을 파이프라인으로 바꾸기

filter나 map을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다

### LAZY ELEMENT(성의 없는 요소)

코드의 구조를 잡을 때 프로그램 요소를 이용하는데 리팩터링을 거쳐 더 이상 필요 없어지면 제거한다.

- 함수 인라인 하기나 클래스 인라인 하기로 처리
- 상속을 사용했다면 계층 합치기

### SPECULATIVE GENERALITY(추측성 일반화)

나중에 필요할 거라는 생각으로 당장 필요 없는 코드를 작성한 부분

- 계층 합치기로 제거
- 함수 인라인 하기나 클래스 인라인 하기로 삭제
- 매개변수는 함수 선언 바꾸기로 없애기
- 테스트 코드 외에 사용하지 않는다면 죽은 코드 제거하기

### TEMPORARY FIELD

특정 상황에서만 값이 있는 객체의 임시 필드

- 클래스 추출하기
- 함수 옮기기로 임시 필드 코드를 옮긴다
- 특이 케이스 추가하기로 필드가 유효하지 않을 때 대안을 만든다

### MESSAGE CHAINS

다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드.
이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.

- 위임 숨기기로 해결, 중간 객체들이 중개자가 되어 버리기 쉬우므로 최종 결과 객체가 어떻게 쓰이는지 살펴본다.
- 함수 추출하기, 함수 옮기기로 체인을 숨길 수 있는지 확인 

### MIDDLE MAN

객체의 대표적인 기능, 외부로부터 세부사항을 숨겨주는 캡슐화(encapsulation)가 있다.
캡슐화하는 과정에서 위임이 자주 활용된다.

- 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 한다.
- 위임을 제거 후 호출하는 쪽으로 함수 인라인하기

### INSIDER TRADING

모듈 사이의 데이터 결합도는 생길 수 밖에 없지만, 양을 최소한으로 줄이고 투명하게 처리해야 한다.

- 함수 옮기기와 필드 옮기기로 사적으로 처리하는 부분을 줄인다.
- 공통 부분을 처리하는 제3의 모듈을 만들거나 위임 숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다
- 자식 클래스를 부모 클래스에서 분리해야 할 때가 오면, 서브클래스를 위임으로 바꾸기, 수퍼클래스를 위임으로 바꾸기를 활용

### LARGE CLASS

한 클래스가 일을 많이 하면 필드가 많아짐, 필연적으로 중복 코드가 생기기 쉬운 구조

- 클래스 추출하기로 필드를 묶는다
- 상속 관계로 만드는게 좋다면 수퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기로 적용

거대 클래스의 특정 기능 그룹만 주로 사용한다면

- 클래스 추출하기, 수퍼클래스 추출하기, 타입 코드를 서브 클래스로 바꾸기로 여러 클래스로 분리

### ALTERNATIVE CLASSES WITH DIFFERENT INTERFACES

클래스 교체가 가능하려면 인터페이스가 같아야 함

- 함수 선언 바꾸기로 메서드 시그니처를 일치시킴
- 함수 옮기기를 이용하여 인터페이스가 같게 만듦
- 중복 코드가 생기면 수퍼클래스 추출하기를 고려

### DATA CLASS

데이터 클래스는 필드, getter/setter로만 이루어진 클래스이다.

- public field는 레코드 캡슐화하기로 숨김
- 변경하면 안되는 필드는 세터 제거하기로 접근 차단
- 함수 옮기기로 메서드를 데이터 클래스로 옮길 수 있는지 확인
- 함수 추출하기를 이용해서 옮길 수 있는 부분만 별도 메서드로 추출
- 단계 쪼개기의 결과로 나온 중간 데이터 구조는 불변 필드가 있으므로 캡슐화할 필요 까지는 없음

### REFUSED BEQUEST(상속 포기)

부모 클래스의 유산을 원하지 않을 경우, 계층 구조를 잘못 설계했을 가능성이 높다.

- 같은 계층에 서브 클래스를 하나 만들고 메서드 내리기, 필드 내리기를 활용, 물려받고 싶지 않은 코드는 서브 클래스로 넘긴다.

일부 동작을 재활용하기 위한 목적으로 상속을 활용하는데, 실무 관점에서 유용한 방식
냄새를 풍기지만 참을만한 경우가 많다.
상속을 포기할 경우에 문제가 생기면 예전 방식대로 서브클래스를 둔다.

구현을 따르지 않아도 인터페이스는 따라야 하므로

- 서브클래스를 위임으로 바꾸기나 수퍼클래스를 위임으로 바꾸기를 활용해서 상속 메커니즘에서 벗어난다.

### COMMENTS

주석이 장황하게 달렸다면 코드를 잘못 작성했을 경우가 많다.

- 함수 추출하기로 특정 코드 블록이 하는 일에 주석을 남긴다
- 함수 선언 바꾸기로 추가 설명을 하지 않아도 되도록 이름을 바꾼다.
- 시스템 동작의 선행조건이라면 어서션 추가하기를 한다

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

