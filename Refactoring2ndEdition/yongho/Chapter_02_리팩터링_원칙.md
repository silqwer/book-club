# 토론
두 개의 모자를 착용하다가 길을 잃어 다시 처음으로 돌아가서 작업을 하는 경험을 종종합니다.
모자를 적절하게 바꿔 착용하는 노하우가 있나요? 


# 2.1 리팩터링 정의

리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다.

재구성: 코드베이스를 정리하거나 구조를 바꾸는 모든 작업

리팩터링은 성능 최적화와 비슷하다. 목적이 다를 뿐이다.

- 리팩터링: 코드를 이해하고 수정하기 쉽게 만드는 것이다.
- 오로지 속도 개선에만 신경 쓴다.

# 2.2 두 개의 모자

소프트웨어를 개발할 때 목적이 `기능 추가` 냐 아니면 `리팩터링` 이냐를 명확히 구분해 작업한다.

→ 하나의 작업을 마무리하지 않고 두 개의 모자를 번갈아 착용하다가 꼬여서 시간만 보낸 적도 있다.

# 2.3 리팩터링하는 이유

- 소프트웨어 설계가 좋아진다.
- 소프트웨어를 이해하기 쉬워진다.
- 버그를 쉽게 찾을 수 있다.
→ 난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요.
- 프로그래밍 속도를 높일 수 있다.

모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.

코드가 명확하면 보그를 만들 가능성이 준다.

버그를 만들더라도 디버깅하기가 쉽다.

리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있고, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.

처음부터 좋은 설계를 마련하기란 매우 어렵다.

그래서 빠른 개발이라는 숭고한 목표를 달성하라면 리팩터링이 반드시 필요하다.

# 2.4 언제 리팩터링해야 할까?

리팩터링을 녹이는 방법

### 3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일이 세 번째 하게 되면 리팩터링한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.

함수 매개 변수화하기 적용

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.

코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

### 쓰레기 줍기 리팩터링

코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다.


항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.

### 계획된 리팩터링과 수시로 하는 리팩터링

위의 리팩터링은 기회가 될 대만 진행한다.

프로그래밍 과정에 자연스럽게 녹인다.

보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 `수정`하는 것이 그 기능을 가장 바르게 추가하는 길일 수 있음을 안다.

계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다.

→ 리팩터링이 필요한 부분을 발견하면 GitHub issue로 등록해 뒀는데 점점 쌓이며 이슈를 줄이기 힘들었다.

### 오래 걸리는 리팩터링

오래 걸리는 리팩터링에 팀 전체가 리팩터링에 매달리는 데는 회의적이다.

주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.

### 코드리뷰에 리팩터링 활용하기

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다.

### 관리자에게는 뭐라고 말해야 할까?

기술을 모르는 상당수의 관리자와 고객에게는 말하지 마라.

### 리팩터링하지 말아야 할 때

- 외부 API 다루듯 호출해서 쓰는 코드일 때
→ 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
- 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

# 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

→ 항상 여기서 걸리는 듯하다.

리팩터링의 궁극저인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다.

내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편이다.

리팩터링의 본질은 오로지 경제적인 이유로 하는 것이다.

- 시간, 돈, 기간

### 코드 소유권

코드의 소유권을 팀에 두는 것을 선호한다.

오픈 소스 개발 모델을 권장하기도 한다.

### 프랜치

마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

### 테스팅

코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다.

자가 테스트 코드를 마련해야 한다.

### 레거시 코드

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움 된다.


대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

테스트 보강

### 데이터베이스

접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.

# 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다.

YAGNI

- 간결한 설계
- 점진적 설계

YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다.

# 2.7 리팩터링과 소프트웨어 개발 프로세스

XP의 두드러진 특징은 지속적 통합, 자가 테스트코드, 리팩터링 등 개성이 강하면서 상호 의존하는 기법들이 하나로 묶은 프로세스라는 점이다.

테스트 주도 개발: 자가 테스트 코드 + 리팩터링

애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.

리펙토링의 토대

1. 자가 테스트 코드
2. 지속적 통합

# 2.8 리팩터링과 성능

직관적인 설계 vs 성능

저자가 성능을 무시하는 이유는 설계의 순수성을 우선시하거나 조만간 더 바른 하드웨어가 나오리라 믿기 때문이다.

→ 프론트에서 디자인 요소에 성능을 중요시하는 부분은 별로 공감이 되지 않는다.

→ 리팩토링한다고 하면서 너무 고도화, 자동화 처리를 해서 팀원들이 소스코드를 이해하거나 나중에 오류를 수정하기 위해서 많은 시간이 든다면?

빠른 소프트웨어를 작성하는 방법

1. 시간 예산 분배
2. 끊임없이 관심을 기울이는 것

# 2.9 리팩터링의 유래

워드와 켄트는 이런 환경에 특화된 소프트웨어 개발 방법을 고민했고, 그 결과로 XP가 탄생한 것이다

# 2.10 리팩터링 자동화

자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다.

자바를 다룰 때는 인텔리제이나 이클립스에서 지원하는 리팩터링 기능을 사용

자동과 수동 리팩터링을 한다.

→ vscode에서 리팩터링 익스텐션이 있나?

# 2.11 더 알고 싶다면

- 리팩터링 워크북
- 패턴을 활용한 리팩터링
- 디자인패턴
- 리팩토링 데이터베이스
- 리팩토링 html
- 레거시 코드 활용 전략