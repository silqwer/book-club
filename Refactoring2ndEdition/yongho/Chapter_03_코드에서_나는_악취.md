# 토론
많은 스킬들이 소개가 되었는데 실제로 해보지 않으니 감이 잘 옵니다.
감 좀 찾아주세요.

# 3.1 기이한 이름

코드는 단순하고 명료하게 작성

이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.

이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지 중 하나다.

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기

# 3.2 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

- 함수 추출하기
- 문장 슬라이드 하기
- 매서드 올리기

# 3.3 긴 함수

오랜 기간 잘 활용 되는 프로그램들은 하나같이 짦은 함수로 구성됐다.

간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짦게 구성할 때 나오는 것이다.

짦은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.

주석을 달아야 할 만한 부분은 무조건 함수로 만든다.

동작 방식이 아닌 의도가 드러나게 짓는다.

원래 코드보다 길어지더라도 함수로 뽑는다.

- 함수 추출하기
- 임시 변수를 질의 함수로 바꾸기
- 매개변수 객체 만들기
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 조건부 로직을 다형성으로 바꾸기
- 반복문 쪼개기

# 3.4 긴 매개변수 목록

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 매개변수 객체 만들기
- 플래그 인수로 제거하기
- 여러 함수를 클래스로 묶기

# 3.5 전역 데이터

- 변수 캡슐화하기

# 3.6 가변 데이터

- 변수 캡슐화하기
- 변수 쪼개기
- 문장 슬라이드 하기
- 함수 추출하기
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기

# 3.7 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타낸다.

- 단계 쪼개기
- 함수 옮기기
- 함수 추출하기
- 클래스 추출하기

# 3.8 산탄총 수술

뒤엉킨 변경과 비슷하면서 정반대

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기

# 3.9 기능 편애

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 초소로 줄이는데 주력한다. 

함수가 자기가 속한 모듈의 함수나 데이터 보다 다른모듈의 함수나 데이터나 상호작용할 일이 더 많을 때 풍기는 냄새다.

- 함수 옮기기
- 함수 추출하기
- 디자인 패턴 중 전략 패턴과 방문자 패턴: 오버 라이드 해야 할 작업들이 각각의 클래스로 격리되어 수정하기 쉬워짐
- 함께 변경할 대상을 한데 모으는 것

# 3.10 데이터 뭉치

클래스, 함수에서 함께 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다. 

- 클래스 추출하기
- 매개변수 객체 만들기
- 객체 통째로 넘기기

# 3.11 기본형 집착

프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.

이러한 기본형에 집착하여 일관되게 보여주지 못할 때 나는 냄새

- 기본형을 객체로 바꾸기
- 타입 코드를 서브 클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- 매개변수 객체 만들기

# 3.12 반복되는 switch 문

조건부 로직을 다형성으로 바꿔 if 문까지 없애야 한다는 주장도 있다.

똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중해보자. 

조건절을 하나 추가할 때마다 다른 조건부 로직을 찾아 모두 수정해야 하기 때문에 문제가 된다. 

- 다형성

# 3.13 반복문

일급 함수를 지원하는 언어가 많아졌기 때문에 적절히 사용하자. 

- 반복문 파이프라인으로 바꾸기

# 3.14 성의 없는 요소

- 함수 인라인 하기
- 클래스 인라인 하기
- 계층 합치기

# 3.15 추측성 일반화

이 냄새는 `나중에 필요할 거야` 라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 

그 결과 이해, 관리하기 어려워진 코드

당장 걸리적거리는 코드는 눈앞에서 치워버리자

- 계층 합치기
- 함수 인라인 하기
- 클래스 인라인 하기
- 함수 선언 바꾸기
- 죽은 코드 제거하기

# 3.16 임시 필드

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.

이해하기 어렵고, 사용하지 않는 것처럼 보일 수 있다.

- 클래스 추출하기
- 함수 옮기기
- 특이 케이스 추가

# 3.17 메시지 체인

클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻는 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다. 

클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 

- 위임 숨기기
- 함수 추출하기
- 함수 옮기기

# 3.18 중개자

객체의 대표적인 기능 하나로, 외부로부터 세부 사항을 숨겨주는 캡슐화가 있다. 

캡슐화하는 과정에서 위임이 자주 활용된다. 

- 중개자 제거하기

# 3.19 내부자 거래

모듈 사이의 데이터 거래가 많아 결함도가 높아질 때 그 양을 최소로 줄이고 모두 투명하게 처리해야한다. 

- 함수 옮기기
- 필드 옮기기
- 위임 숨기기
- 서브 클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

# 3.20 거대한 클래스

필드 줄이기

클래스가 항시 모든 필드를 사용하지 않을 수 있다. 

클라이언트들이 거대 클래스를 어떻게 이용하는지 패턴을 파악

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브 클래스로 바꾸기

# 3.21 서로 다른 인터페이스의 대안 클래스들

언제든 다른 클래스로 교체

- 함수 선언 바꾸기
- 함수 옮기기
- 슈퍼클래스 추출하기

# 3.22 데이터 클래스

데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.

데이터 저장 용도로만 쓰여 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다. 

- 레코드 캡슐화하기
- 세터 제거하기
- 함수 옮기기
- 함수 추출하기
- 단계 쪼개기

# 3.23 상속 포기

서브 클래스는 부모로부터 메서드와 데이터를 물려받는다.

서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다. 

- 매서드 내리기
- 필드 내리기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기

# 3.24 주석

주석이 많으면 이 장에서 소개한 온갖 악취를 풍기는 코드가 나오기 쉽다.

주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다. 

코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수 있다. 이런 정보는 나중에 코드를 수정해야 할 프로그래머에게, 특히 건망증이 심한 프로그래머에게 도움이 될 것이다.

- 함수 추출하기
- 함수 선언 바꾸기
- 어셔선 추가하기