# 5.1 애플리케이션 분리의 중요성

자바스크립트 모듈은 ES2015의 출시와 함께 표준화되었다. 모듈형 자바스크립트는 사실상의 표준이 되었다.

# 5.2 모듈 가져오기와 내보내기

모듈을 사용하면 각 기능에 맞는 독립적인 단위로 코드를 분리할 수 있다.

모듈형 언어가 되기 위해서는 의존성을 가진 모듈을 가져오고, 내보낼 수 있어야 한다.

`NOTE` .mjs는 모듈 파일과 기존 스크립트(.js)를 구분하기 위해 쓰이는 모듈 전용 확장자이다.
.mjs 확장자를 사용하여 런타임 및 빌드 도구에 모듈임을 알릴 수 있다.

# 5.3 모듈 객체

모듈 객체를 가져오면 모듈 리소스를 깔끔하게 가져올 수 있다.

```tsx
// 파일명: cakeFactory.mjs

import * as Staff from "/modules/staff.mjs";

export const oven = {
  makeCupcake(toppings) {
    Staff.baker.bake("cupcake", toppings);
  },
  makePastry(mSize) {
    Staff.pastryChef.make("pastry", type);
  },
};
```

# 5.4 외부 소스로부터 가져오는 모듈

ES20215부터는 외부 소스에서 가져오는 원격 모듈을 쉽게 가져올 수 있게 되었다.

```tsx
import { cakeFactory } from "https://example.com/modules/cakeFactory.mjs";

// 미리 로드된 정적 가져오기
cakeFactory.oven.makeCupcake("sprinkles");
cakeFactory.oven.makeMuffin("large");
```

# 5.5 정적으로 모듈 가져오기

정적 가져오기는 메인 코드를 실행하기 전에 먼저 모듈을 다운로드하고 실행해야 한다. 따라서 초기 페이지 로드 시 많은 코드를 미리 로드해야 하므로 성능에 문제가 생길 수 있다.

# 5.6 동적으로 모듈 가져오기

지연 로딩 모듈을 사용하면 필요한 시점에 로드할 수 있다.

동적 가져오기는 함수와 비슷한 새로운 형태의 가져오기이다. import(url)는 요청된 모듈의 네임스페이스 객체에 대한 프로미스 객체를 반환한다.

```tsx
form.addEventListener("submit", (e) => {
  e.preventDefault();
  import("/modules/cakeFactory.js").then((module) => {
    // 가져온 모듈 사용하기
    module.oven.makeCupcake("sprinkles");
    module.oven.makeMuffin("large");
  });
});
```

## 5.6.1 사용자 상호작용에 따라 가져오기

일부 기능은 사용자가 상호작용할 때만 필요할 수 있다. 채팅 창이나 다이얼로그, 비디오 등이 대표적인 예이다.

## 5.6.2 화면에 보이면 가져오기

IntersectionObserver API를 사용하면 컴포넌트가 화면에 보이는지 감지할 수 있고, 이에 따라 모듈을 동적으로 로드할 수도 있다.

# 5.7 서버에서 모듈 사용하기

Node는 type이 module이라면 .mjs와 .js로 끝나는 파일을 자바스크립트 모듈로 취급한다.

# 5.8 모듈을 사용하면 생기는 이점

- 한 번만 실행된다
- 자동으로 지연 로드된다
- 유지보수와 재사용성이 쉽다
- 네임스페이스를 제공한다
- 사용하지 않는 코드를 제거한다

# 5.9 생성자, 게터, 세터를 가진 클래스

모듈과 클래스의 차이점은 모듈은 가져오기와 내보내기를 통해 클래스는 class 키워드를 통해 정의할 수 있다는 점이다.

클래스의 멤버는 기본적으로 공개 상태이며, #(해시)를 앞에 붙여 비공개 멤버로 만들 수 있다.

자바스크립트 클래스는 static 키워드를 통해 정적 메서드와 프로퍼티를 정의할 수 있다. 정적 멤버는 클래스를 초기화하지 않고도 사용할 수 있다. 주로 어떠한 설정이나 캐시 데이터를 보관하기 위해 사용된다.

# 5.10 자바스크립트 프레임워크와 클래스

지난 몇 년간 리엑트와 같은 최신 자바스크립트 라이브러리와 프레임워크는 클래스의 대체제를 도입해 왔다. 대표적으로 리엑트 hooks는 클래스를 사용하지 않고도 리액트의 상태와 라이프사이클을 다를 수 있도록 만들어졌다.
