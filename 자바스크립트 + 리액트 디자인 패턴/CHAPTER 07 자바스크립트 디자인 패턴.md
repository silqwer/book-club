<aside>
💡

패턴을 선택할 때 패턴이 실질적인 구현에 도움이 되는지 고려해야 한다. 즉, 디자인 패턴에 대해 정확히 알고 사용할 때를 잘 파악하게 된다면 애플리케이션 아키텍처에 올바른 디자인 패턴을 적용하기 수월해진다는 뜻이다.

</aside>

# 7.1 생성 패턴

생성 패턴은 객체를 생성하는 방법을 다룬다.

- 생성자 패턴
- 모듈 패턴
- 노출 모듈 패턴
- 싱글톤 패턴
- 프로토타입 패턴
- 팩토리 패턴

# 7.2 생성자 패턴

`NOTE` 객체 생성자는 특정 유형의 객체를 생성할 때 사용되었다. 객체가 처음 생성되었을 때 인수로 받아온 값을 객체 멤버의 변수와 메서드에 할당하는 동시에 사용할 준비를 마친다.

<figure>
    <img src="./images/스크린샷 2025-06-08 오후 3.23.49.png" alt="생성자 패턴" width="600" />
    <figcaption>그림 7-1. 생성자 패턴</figcaption>
</figure>

## 7.2.1 객체 생성

자바스크립트에서 새로운 객체를 만들 때 사용하는 세 가지 일반적인 방법

1. 리터럴 표기법을 사용하여 빈 객체 생성

   ```tsx
   const newObject = {};
   ```

2. Object.create() 메서드를 사용하여 빈 객체를 생성

   ```tsx
   const newObject = Object.create(Object.prototype);
   ```

3. new 키워드를 사용하여 빈 객체를 생성

   ```tsx
   const newObject = new Object();
   ```

객체에 키와 값을 할당하는 방법은 아래와 같다.

1. 도트 dot(.) 문법

   ```tsx
   newObject.someKey = "hellow";
   ```

2. 대괄호 문법

   ```tsx
   newObject["someKey"] = "hellow";
   ```

3. Object.defindProperty

   ```tsx
   Object.defineProperty(newObject, 'someKey', {
   	value: 'hellow',
   	writable: true
   	enumerable: true
   	configurable: true
   });
   ```

## 7.2.2 생성자의 기본 특징

ES2015에 도입된 자바스크립트의 클래스는 객체 템플릿의 정의하고 캡슐화 및 상속을 구현할 수 있게 했다.

## 7.2.3 프로토타입을 가진 생성자

생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다.

# 7.3 모듈 패턴

모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는 데 효과적으로 활용된다.

## 7.3.1 객체 리터럴

객체 리터럴 표기법은 객체는 중괄호 안에서 키와 값을 쉼표로 구분하여 객체를 정의하는 방법이다.

## 7.3.2 모듈 패턴

개발자들은 자바스크립트 모듈을 사용하여 객체, 함수, 클래스, 변수 등을 구성하여 다른 파일에 쉽게 내보내거나 가져올 수 있다.

<figure>
    <img src="./images/스크린샷 2025-06-08 오후 3.34.57.png" alt="모듈 패턴" width="600" />
    <figcaption>그림 7-2. 모듈 패턴</figcaption>
</figure>

### 비공개

모듈 패턴은 클로저를 활용해 `비공개` 상태와 구성을 캡슐화한다.

모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수 있다.

모듈 패턴은 즉시 실행 함수를 사용해 객체를 반환한다.

ES2019(ES10) 이전의 자바스크립트에서는 접근 제한자(#, 해시)를 지원하지 않아 엄밀히 말해 `비공개`라는 개념이 존재하지 않았다.

### 역사

역사적인 관점에서 보자면 모듈 패턴은 리처드 콘포드를 비롯한 여러 사람들에 의해 발명되었다.

### 예제

모듈의 클로저 내부로 스코프가 제한되어 오직 공개된 api만 접근할 수 있다.

- 비공개 자유성: 모듈 내부에서만 사용 가능한 비공개 함수를 자유롭게 만들 수 있다. 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.
- 디버깅 용이성: 대개 함수는 선언되고 이름이 정해지므로, 어떤 함수가 예외를 발생시켰는지 알아내려고 할 때 디버거에서 콜 스택을 찾기 쉬워진다.

## 7.3.3 모듈 패턴의 변형

### 믹스인 가져오기 변형

이 변형된 패턴은 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달 할 수 있게 한다.

### 내보내기 변형

## 장점

자바스크립트의 관점에서 볼 때 모듈 패턴은 캡슐화 개념보다 객체 지향 프로그래밍 지식을 가진 초보 개발자가 이해하기 쉽다.

모듈 사이의 의존성을 관리하고 전역 요소를 원하는 만큼 넘겨주어 코드의 유지보수를 용이하게 하고 독립적으로 만들어준다.

모듈 패턴은 공개되면 안 되는 코드를 캡슐화할 수 있다. 덕분에 여러 의존성을 동시에 사용할 수 있고 이름의 충돌도 피할 수 있다.

### 단점

모듈 패턴의 단점은 공개와 비공개 맴버를 서로 다르게 접근해야 한다는 점이다. 공개 여부를 바꾸고 싶다면 값이 위치한 파일로 가서 각각 바꾸어주어야만 한다. → 이게 단점이 될 수 있나?

자동화 단위 테스트에서 비공개 맴버는 제외된다는 것과 핫 픽스가 필요한 오류를 고칠 때 복잡도를 높인다는 점이다.

## 7.3.4 WeakMap을 사용하는 최신 모듈 패턴

ES6에서 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체이다. 참조되지 않는 키는 가비지 컬렉션의 대상이 된다.

## 7.3.5 최신 라이브러리와 모듈

자바스크립트 라이브러리를 만들 때 모듈 패턴을 사용할 수 있다.

# 7.4 노출 모듈 패턴

모든 함수와 변수를 비공개 스코프에 정의하고, 공개하고 싶은 부분만 포인터를 통해 비공개 요소에 접근할 수 있게 해주는 익명 객체를 반환하는 패턴이다.

## 7.4.1 장점

노출 모듈 패턴을 사용하면 코드의 일관성이 유지된다. 또한 모듈의 가장 아래 위치한 공개 객체를 더 알아보기 쉽게 바꾸어 가독성을 향상시킨다.

## 7.4.2 단점

노출 모듈 패턴의 단점은 비공개 함수를 참조하는 공개 함수를 수정할 수 없다는 것이다.

# 7.5 싱글톤 패턴

싱클톤 패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다.

이 패턴은 전역에서 접근 및 공유해야 하는 단 하나의 객체가 필요할 때 유용하다.

싱글톤 패턴을 구현하려면 이미 존재는 인스턴스가 없어야 한다. 인스턴스가 이미 존재할 경우에는 해당 인스턴스의 참조를 반환한다.

싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용한다는 것이다.

### 싱글톤 패턴의 적합성

- 클래스의 인스턴스는 정확히 하나만 있어야 하며 눈에 잘 보이는 곳에 위치시켜 접근을 용이하게 해야 한다.
- 싱글톤의 인스턴스는 서브클래싱을 통해서만 확장할 수 있어야 하고, 코드의 수정 없이 확장된 인스턴스를 사용할 수 있어야 한다.

싱글톤은 유용하지만 자바스크립트에서 싱글톤이 필요하다는 것은 설계를 다시 생각해 봐야 한다는 신호일 수 있다.

자바스크립트에서 싱글톤 클래스를 사용하는 것은 다음과 같은 단점이 있다.

- 싱글톤임을 파악하는 것이 힘들다
- 테스트하기 힘들다
- 신중한 조정이 필요하다.

## 7.5.1 리액트의 상태 관리

싱클톤 대신 Context API나 리덕스 같은 전역 상태 관리 도구를 이용하여 개발할 수 있다.

# 7.6 프로토타입 패턴

프로토타입 패턴을 이미 존재하는 객체를 복제해 만든 템플릿 기반으로 새 객체를 생성하는 패턴이다.

프로토타입 패턴은 프로토타입의 상속을 기반으로 한다. 이 패턴에선 프로토타입 역할을 할 전용 객체를 생성하게 된다.

<figure>
    <img src="./images/스크린샷 2025-06-14 오후 12.55.54.png" alt="프로토타입 패턴" width="600" />
    <figcaption>그림 7-3. 프로토타입 패턴</figcaption>
</figure>

프로토타입 상속은 클래스처럼 따로 정의되는 것이 아니라, 이미 존재하는 다른 객체를 복제하여 새로운 객체를 만들어 낸다.

프로토타입 패턴의 장점은 다른 언어의 기능을 따라 하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것이다.

객체 내에 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가르키게 할 수 있다.

ES2015+에서는 객체를 생성하기 위해 클래스와 생성자를 사용할 수 있다.

클래스와 생성자도 결국 내부적으로는 함수와 프로토타입으로 컴파일된다. 즉 클래스와 생성자를 사용한다고 하더라도 여전히 프로토타입의 장점과 동시에 성능상 이점을 누리고 있는 것이다.

ECMAScript 5 표준에 따라 프로토타입의 상속은 Object.create를 필요로 한다. 다시 말해 Object.create는 프로토타입 객체를 생성하고 특정 속성을 추가 할 수도 있다.

# 7.7 팩토리 패턴

팩토리패턴은 객체를 생성하는 생성 패턴의 하나이다.

<figure>
    <img src="./images/스크린샷 2025-06-14 오후 1.00.56.png" alt="팩토리 패턴" width="600" />
    <figcaption>그림 7-4. 팩토리 패턴</figcaption>
</figure>

팩토리 패턴은 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 특히 유용하다.

## 7.7.1 팩토리 패턴을 사용하면 좋은 상황

- 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕 타이핑 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용하다

## 7.7.2 팩토리 패턴을 사용하면 안 되는 상황

잘못된 상황에 팩토리 패턴을 적용하면 애플리케이션의 복잡도가 크게 증가할 수 있다.

팩토리 패턴은 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가시킬 수 있다.

## 7.7.3 추상 팩토리 패턴

추상 팩토리 패턴은 같은 목표를 가진 각각의 팩토리들을 하나의 그룹으로 캡슐화하는 패턴이다.

또한 객체가 어떻게 생성되는지에 대한 세부사항을 알 필요 없이 객체를 사용할 수 있게 한다.

객체의 생성 과정에 영향을 받지 않아야 하거나 여러 타입의 객체로 작업해야 하는 경우에 추상 팩토리를 사용하면 좋다.

# 7.8 구조 패턴

구조 패턴은 클래스와 객체의 구성을 다룬다. 구조 패턴은 클래스와 객체를 체계적으로 구성하는 최고의 방법과 사례를 제공한다.

# 7.9 퍼사드 패턴

퍼사드란 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것을 뜻한다.

사드 패턴은 심층적인 복잡성을 숨기고, 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴이다.

<figure>
    <img src="./images/스크린샷 2025-06-14 오후 1.08.13.png" alt="퍼사드 패턴" width="600" />
    <figcaption>그림 7-5. 퍼사드 패턴</figcaption>
</figure>

퍼사드는 jQuery 같은 자바스크립트 라이브러리에서 흔히 볼 수 있는 구조 패턴이다.

예를 들어 jQuery의 $(el).css나 $(el).animate() 같은 메서드를 사용할 때마다 퍼사드를 사용하는 것이다.

퍼사드 패턴은 클래스의 인터페이스를 단순화하고 코드의 구편 부분과 사용 부분을 분리한다.

이를 통해 하위 시스템에 직접 접근하기보단 간접적으로 상호작용하여 에러를 줄일 수 있다.

퍼사드의 장점은 사용하기 쉽다는 점과 패턴 구현에 필요한 코드의 양이 적다는 점이다.

```tsx
const addMyEvent = (el, ev, fn) => {
  if (el.addEventListener) {
    el.addEventListener(ev, fn, false);
  } else if (el.attachEvent) {
    el.attachEvent(`on${ev}`, fn);
  } else {
    el[`on${ev}`] = fn;
  }
};
```

# 7.10 믹스인 패턴

C++나 List 같은 전통적인 프로그래밍 언어에서 믹스인은 서브클래스가 쉽게 상속받아 기능을 재사용할 수 있도록 하는 클래스이다.

# 7.11 서브클래싱

ES2015+에서 도입된 기능을 통해 기존 또는 부모 클래스를 확장할 수도, 부모 클래스의 메서드를 호출할 수도 있게 되었다.

부모 클래스를 확장하는 자식 클래스를 서브클래스라고 한다.

서브클래싱이란 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것을 뜻한다.

서브클래스는 부모 클래스에 먼저 정의된 메서드를 오버라이드하는 것도 가능하다.

서브클래스의 메서드는 오버라이드된 부모 클래스의 메서드를 호출할 수 있는데, 이를 메서드 체이닝이라고 부른다.

# 7.12 믹스인

자바스크립트에서는 기능의 확장을 위해 믹스인의 상속을 이용한다. 새롭게 만들어지는 클래스는 부모 클래스로부터 메서드와 속성을 부여받는다.

또한 자신만의 속성과 메서드를 정의할 수 있다. 함수의 재사용을 향상시키기 위해 이러한 특징을 활요할 수 있다.

<figure>
    <img src="./images/스크린샷 2025-06-14 오후 1.15.39.png" alt="믹스인" width="600" />
    <figcaption>그림 7-6. 믹스인</figcaption>
</figure>

## 7.12.1 장점과 단점

믹스인은 함수의 중복을 줄이고 재사용성을 높인다. 애플리케이션에서 객체 인스턴스 사이에 공유되는 기능이 있다면 믹스인을 통해 기능을 공유하여 중복을 피하고 고유 기능을 구현하는 데에 집중할 수 있다.

# 7.13 데코레이터 패턴

데코레이터 패턴은 코드 재사용을 목표로 하는 구조 패턴이다. 믹스인과 마찬가지로 객체 서브클래싱의 다른 방법이라고 생각하면 된다.

<figure>
    <img src="./images/스크린샷 2025-06-14 오후 1.19.40.png" alt="데코레이터 패턴" width="600" />
    <figcaption>그림 7-7. 데코레이터 패턴</figcaption>
</figure>

자바스크립트는 데코레이터를 사용할 수 있는 베이스 클래스를 만들 수 있다. 자바스크립트 클래스 인스턴스 객체에 새로운 속성이나 메서드를 추가하는 것은 간단하다.

# 7.14 의사 클래스 데코레이터

## 7.14.1 인터페이스

인터페이스는 스스로 문서의 역할을 하고 재사용성을 높인다.

## 7.14.2 추상 데코레이터

추상 데코레이터는 모든 가능한 조합의 클래스를 따로 정의하지 않고도, 필요한 만큼의 데코레이터만을 사용하여 베이스 클래스에 독립적으로 기능을 추가할 수 있게 해준다.

데코레이터는 객체를 동적으로 확장할 수 있으므로, 이미 동작하는 시스템의 내용을 변경하기에 매우 적합한 패턴이다. 가끔은 각 객체 타입의 개별 서브클래스를 관리하는 것보다 객체를 감싸는 데코레이터를 만드는 게 더 쉬울 때도 있다.

# 7.15 장점과 단점

데코레이터 패턴의 객체는 새로운 기능으로 감싸져 확장되거나 데코레이트될 수 있으며 베이스 객체가 변경될 걱정 없이 사용할 수 있다. 더 넓은 의미에서 봤을 때 수많은 서브클래스에 의존할 필요도 없다.

- 주의점
  - 네임 스페이스에 작고 비슷한 객체를 추가하기 때문에, 잘 관리하지 않는다면 애플리케이션의 구조를 무척 복잡하게 만들 수도 있다. → 문서화로 해결

# 7.16 플라이웨이트 패턴

플라이웨이트 패턴은 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결 방법이다. 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하는 목적을 가지고 있다.

<figure>
    <img src="./images/스크린샷 2025-06-21 오전 10.17.36.png" alt="플라이웨이트 패턴" width="600" />
    <figcaption>그림 7-8. 플라이웨이트 패턴</figcaption>
</figure>

## 7.16.1 사용법

1. 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유
2. DOM 레이어에서 비슷한 동작을 하는 이벤트 핸들러를 모든 자식 요소에 등록하기보다는 부모 요소 같은 중앙 이벤트 관리자에게 맡기는 방법

## 7.16.2 데이터 공유

- 내재적 상태
  - 객체의 내부 메서드에 필요한 것이며, 없으면 절대로 동작하지 않는다.
- 외재적 상태
  - 제거되어 외부에 저장될 수 있다.

## 7.16.3 전통적인 플라이웨이트 구현 방법

## 7.16.4 플라이웨이트로 변환하기

## 7.16.5 기본 팩토리

## 7.16.6 외부 상태 관리하기

모든 함수는 메모리를 차지하지만, 플라이웨이트 패턴을 사용하면 함수들은 모든 객체에 각각 존재하는 게 아니라, 관리자 내부에 한 번만 존재하게 되어 메모리를 절약할 수 있다.

## 7.16.7 플라이웨이트 패턴과 DOM 객체

DOM은 하향식(이벤트 캡처링)과 상향식(이벤트 버블링) 두 가지 방식의 이벤트 감지를 지원한다.

플라이웨이트는 이벤트 버블링 과정을 추가 조정하는 데에 사용할 수 있다.

## 7.16.8 예시: 중앙 집중식 이벤트 핸들링

최상위 컨테이너에 플라이웨이트를 부착하여 하위 요소로부터 전달되는 이벤트를 감지할 수 있다.

감지한 이벤트는 필요에 따라 간단하거나 복잡한 로직을 적용하여 원하는 기능을 구현하면 된다.

개별적으로 관리되었던 많은 동작을 공유된 하나의 공작으로 바꾸어 메모리를 절약할 수 있게 해준다.

# 7.17 행위 패턴

행위 패턴은 객체 간의 의사소통을 돕는 패턴이다. 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 한다.

- 관찰자 패턴
- 중재자 패턴
- 커맨드 패턴

# 7.18 관찰자 패턴

관찰자 패턴은 한 객체가 변경될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴이다.

변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다.

한 객체를 관찰하는 여러 객체들이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알람을 보낸다.

<figure>
    <img src="./images/스크린샷 2025-06-21 오전 10.36.12.png" alt="관찰자 패턴" width="600" />
    <figcaption>그림 7-9. 관찰자 패턴</figcaption>
</figure>

주체가 관찰자에게 중요한 변경 사항을 알려야 할 때, 변경에 대한 알림과 함께 관련 정보를 모든 관찰자에게 전달한다. 관찰자가 더 이상 주체의 변경에 대한 알림을 받고 싶지 않을 경우, 관찰자 목록에서 제거하면 된다.

관찰자 패턴의 구성 요소

- 주체
  - 관찰자 리스트를 관리하고, 추가와 삭제를 가능하게 한다.
- 관찰자
  - 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공한다.
- 구체적 주체
  - 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, ConcreteObserver의 상태로 저장한다.
- 구체적 관찰자
  - ConcreteSubject의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수도 있도록 한다.

## 7.18.1 관찰자 패턴과 발행/구독 패턴의 차이점

자바스크립트 환경에서는 발행/구독 패턴이라는 변형된 형태의 구현이 더 널리 사용된다.

관찰자 패턴에서는 이벤트 발생에 대해 알림을 받기를 원하는 관찰자 객체가 이벤트를 발생시키는 주체 객체에 알림 대상으로서 등록되어야 한다. 

<figure>
  <img src="./images/스크린샷 2025-07-26 오전 8.31.33.png" alt="발행/구독 패턴" width="600" />
  <figcaption>발행/구독 패턴</figcaption>
</figure>

발행/구독 패턴

발행/구독 패턴에서는 이벤트 알림을 원하는 구독자와 이벤트를 발생시키는 발행자 사이에 토픽/이벤트 채널을 둡니다.

발행/구독 패턴의 핵심은 발행자와 구독자를 각자 독립적으로 유지한다는 것이다.

발행/구독 패턴에서는 적절한 이벤트 핸들러를 가지고 있는 구독자라면 누구나 발행자가 전파하는 토픽 알림을 받게 할 수 있다.

발행/구독 패턴의 핵심은 시스템의 구성 요소 간에 느슨한 결합을 도모한다는 것이다. 객체(발행자)가 다른 객체(구독자)의 메서드를 직접 호출하는 대신, 구독자는 특정 작업이나 활동을 구독하고 해당 작업이나 활동이 발생했을 때 알림을 받게 된다.

## 7.18.2 장점

애플리케이션을 더 작고 느슨하게 연결된 부분으로 나눌 수 있고, 결과적으로 코드의 관리와 재사용성을 높일 수 있다.

관찰자 패턴 또는 발행/구독 패턴을 사용하면 주체와 객체 사이에 동적인 관계가 형성된다. 

## 7.18.3 단점

발행자는 시스템의 연결이 분리된 특성 때문에 장애를 알 수 있는 방법이 없다. 

구독자들이 서로의 존재에 대해 전혀 알 수 없고 발행자를 변경하는 데 드는 비용을 파악할 수 없다.

구독자와 발행자 사이의 관계가 동적으로 결정되기 때문에 어떤 구독자가 어떤 발행자에 의존하는지 추적하기 어렵다. 

## 7.18.4 발행/구독 패턴 구현하기

관찰자 패턴을 사용한다면 애플리케이션 전반에 걸쳐 발생하는 다양한 이벤트 알림을 원하는 만큼 자세한 수준으로 분리할 수 있다.

# 7.19 중재자 패턴

중재자 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴이다. 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다

중재자 패턴은 구성 요소 간의 관계를 관리함으로써 직접 참조를 없애고 느슨한 결합을 가능하게 한다. 이는 시스템의 결합도를 낮추고 구성 요소를 재사용성을 높여준다.

<figure>
  <img src="./images/스크린샷 2025-07-26 오전 8.42.29.png" alt="중재자 패턴" width="600" />
  <figcaption>중재자 패턴</figcaption>
</figure>

중재자 패턴

다른 사례로는 DOM의 이벤트 버블링과 이벤트 위임을 둘 수 있다. 시스템의 모든 이벤트 등록이 이벤트가 일어날 개별 DOM 노드 대신 최상위 Document 객체를 대상으로 했을 경우 Document 객체는 사실상 중재자 역할을 하게 되는 것이다.

## 7.19.1 간단한 중재자 구현

중재자는 객체 간의 워크플로를 제어한다. 이를 위해 객체 리터럴 이상의 복잡한 구조는 필요하지 않다.

## 7.19.2 유사점과 차이점

중재자 패턴과 이벤트 집합 패턴에 유사점은 이벤트와 서드 파티 객체라는 두 가지 핵심 요소로 요약할 수 있다.

### 이벤트

이벤트 집합 패턴은 그 자체로 이벤트를 처리하기 위한 목적으로 설계된 패턴이다. 하지만 중재자 패턴은 단순히 편리하기 때문에 이벤트를 활용할 뿐이다.

### 서드 파티 객체

이벤트 집합 패턴 자체는 이벤트 발행자와 구독자에 대해 서드 파티 객체이며, 모든 이벤트가 통과하는 중앙 허브의 역할을 한다.

이벤트 집합 패턴에서 서드 파티 객체는 알 수 없는 수의 소스에서 알 수 없는 수의 핸들러로 이벤트가 연결되도록 지원하는 역할만 한다. 실행되어야 하는 모든 워크플로와 비즈니스 로직은 이벤트를 발생시키는 객체와 처리하는 객체에 직접 구현된다.

이벤트 집합 패턴은 발행 후 망각 방식의 소통 모델을 사용한다.

## 7.19.3 이벤트 집합 패턴의 활용

일반적으로 이벤트 집합 패턴은 직접적인 구독 관계가 많아질 경우 또는 전혀 관련 없는 객체들 간의 소통이 필요할 때 사용된다.

## 7.19.4 중재자 패턴의 활용

중재자 패턴을 도입함으로써 개별 뷰 간의 직접 참조로 인한 강한 결합을 방지하고, 비즈니스 로직에 따른 워크플로를 명확하고 효율적으로 모델링할 수 있다.

## 7.19.5 이벤트 집합 패턴(발행/구독)과 중재자 패턴 결합하기

메뉴 항목을 선택하는 것은 애플리케이션 전반에 걸쳐 연쇄적인 변화를 일으킬 수 있다. 일부 변화는 서로 독립적이므로 이벤트 집합 패턴을 사용하기 적합하다.

상호 연관성을 갖는 변화가 존재할 경우 중재자 패턴을 사용하여 구현하는 것이 적합하다.

## 7.19.6 최신 자바스크립트에서 중재자 패턴과 미들웨어

Express.js에서 next() 메서드를 통해 요청과 응답 사이클의 다음 콜백 함수를 호출할 수 있다. 

## 7.19.7 중재자 패턴 vs 퍼사드 패턴

중재자 패턴은 모듈이 명시적으로 중재자 패턴을 참조함으로써 모듈 간의 상호작용을 중앙집중화한다. 이는 번질적으로 다방향성을 지닌다. 

퍼사드 패턴은 모듈 또는 시스템에 직관적인 인터페이스를 제공하지만 추가 기능을 구현하지 않는다. 시스템 내 다른 모듈은 퍼사드의 개념을 직접적으로 인지하지 못하므로 단방향성을 지닌다.

# 7.20 커맨드 패턴

커맨드 패턴은 메서드 호출, 요청 또는 작업을 단일 객체로 캡슐화하여 추후에 실행할 수 있도록 해준다.  커맨드 패턴은 명령을 실행하는 객체와 명령을 호출하는 객체 간의 결합을 느슨하게 하여 구체적인 클래스(객체)의 변경에 대한 유연성을 항샹시킨다.

<figure>
  <img src="./images/스크린샷 2025-07-26 오전 9.00.22.png" alt="커맨드 패턴" width="600" />
  <figcaption>커맨드 패턴</figcaption>
</figure>
