# 4장 귀족 정치, 민주주의, 시스템 설계

## 개념적 일관성

일관성은 여덟 세대에 걸친 건축가들의 자기희생으로 얻어진 것이다.

프로그래밍 시스템에서는 대부분 대성당보다 훨씬 심각한 개념적 불일치가 발견된다.

대개 여러 명이 설계 작업을 나눈 경우에 생긴다.

저자는 개념적 일관성이야말로 시스템 설계에서 가장 중요하게 고려할 사항이라고 주장한다.

좋기는 하지만 연관성이 없고 조율도 안 된 기능을 많이 넣기보다는 이례적인 일부 기능이나 개선 사항을 빼더라도 일련의 설계 사상을 고수하는 편이 더 낫다.

## 개념적 일관성의 획득

사용의 용이성은, 시스템을 공부하고 외우며 매뉴얼을 찾는 데 소모된 시간보다 기능을 명세할 때 얻은 시간적 이득이 클 때에만 향상되었다고 할 수 있다.

기능이나 단순함은 어느 한 가지만으로는 좋은 설계를 만들어 낼 수 없다.

일 정 수준의 기능을 제공한다는 가정하에서라면, 최대한 단순하고 명확하게 사용할 수 있는 시스템이 최상이다.

단순성과 명확성은 개념적 일관성에서 비롯되는 것이다.

시스템의 모든 부분에서는 동일한 철학이 반영되어 있어야 하며 요구 조건에 대한 밸런싱도 같아야 한다.

각 부분에 사용된 기법은 구문적으로 동일해야 하며 사용된 개념은 의미적으로 비슷해야 한다.

사용의 용의성이 설계의 통일성과 개념적 일관성을 가져오게 된다.

## 귀족 정치와 민주주의

개념적 일관성은 이제 시스템의 설계가 한 명 또는 생각을 같이하는 극소수에 의해 이루어지도록 한다.

일정 압박 때문에 시스템 구축에는 많은 사람의 도움이 필요하게 된다. 이때 두 가지 기법을 쓸 수 있다.

1. 아키텍처와 구현 작업을 주의 깊게 나누는 것
2. 프로그램 구현 팀의 구성에 새로운 방식 도입

아키텍처는 반드시 구현 부와 세심하게 구분되어야 한다.

아키텍처가 `무슨 일` 이 일어날지 정하는 것이라면, 구현부는 그것이 `어떻게` 현실화되는지 정한다.

아키테거를 익힌 뒤에 손목시계 분 아니라 교회 탑에 걸린 시계를 보고도 몇 시인지 알 수 있다.

실제 구현과 그 제품화는 시계 껍데기 속에서 무슨 일이 일어나는지, 공급 방식, 제어 방법 등 어떤 것이 사용되는지 같은 것을 기술하는 일이다.

시스템의 개념적 일관성이 사용의 용이성을 결정한다는 것이다.

아무리 훌륭한 기능이나 아이디어라 해도 시스템의 기본 개념에 들어맞지 않는다면 배제하는 것이 상책이다.

전체 설계를 폐기하고 기본 개념을 달리해서 새로 시작하는 편의 낫다.

귀족 정치에 관한 질문에 예라는 답

- 아키텍트는 소수여만 하며 그들이 빚어 난 결과물은 구현자들의 것보다 더 오래 지속되어야 하기 때문이다.
- 시스템이 개념적 일관성을 가져야 한다면, 누군가가 그 개념을 통제해야만 한다. 이것이 설령 귀족 정치라 해도 양해를 구할 일은 아니다.

귀족 정치에 관한 질문에 아니오라는 답

- 외부적인 명세를 기술하는 것이 구현 방안을 설계하는 것보다 더 창조적이지 않다는 점 때문이다.

어떤 아키텍처에 준하여 구현 방안을 설계하는 것은, 시스템의 외부 명세를 설계할 때만큼이나 많은 창의성과 새로운 아이디어, 기술적인 탁월함을 요구한다.

사용의 용이함이 아키텍츠에게 달려 있는 것처럼 제품의 가격 대 성능 비는 구현자의 손에 달려 있다.

외부로부터 아키텍처가 주어진다는 사실이 구현 담당 그룹의 창조성을 저해하는 것이 아니라 더 높인다고 생각한다.

구현자들은 그 즉시 문제 안에서 누구도 다루지 않았던 부분에 초점을 맞출 것이며 거기에서 독창성이 솟아나기 시작한다.

## 구현자들은 기다리는 동안 무엇을 하는가?

잘못된 결정에는 일정 압박, 그리고 150명의 구현 담당에게 일거리를 주어야 한다는 점이었다.

구현 작업 역시 최고의 창조적 행위인 것이다.

구현 중에 창조성과 독창성을 발휘할 기회가 그리 줄어드는 것도 아닐뿐더러, 오히려 그로 인해 창조성의 수준이 더 높아질 수도 있다.

창조적인 작업은 전체로 보아 뚜렷한 세 단계를 거친다.

1. 아키텍처
2. 구현
3. 제품화

개념적 일관성을 갖춘 시스템에는 단일한 철학이 반영되어 있어야 하고, 사용자가 접하게 될 명세는 소수의 머릿속에서 나와야 한다.

폭넓게 수평적으로 나뉜 일이 수직적 분업에 의해 대폭 줄어든 셈이고, 그 결과는 극단적으로 단순화된 커뮤니케이션과 향상된 개념적 일관성으로 나타난다.

# 5장 두 번째 시스템 효과

## 아키텍트를 위한 소통 훈련

실무에서는 일찍부터 지속적으로 소통하는 것이 중요하다.

책임 구분을 모호하게 하지 않고도 아키텍트는 비용에 대한 감을 잡고 구현자는 설계에 대한 확신을 얻을 수 있을 것이다.

추정 비용이 너무 높게 나올 경우 두 가지 해법

1. 설계를 축소
2. 비용이 적게 드는 구현 방법으로 대응
   1. 구현자에게 지시가 아닌 제안
   2. 한 가지 구현 방법은 제시
   3. 목적을 똑같이 만족하는 다른 방안도 수용
   4. 제안은 조용히 개인적으로 이야기
   5. 개선안을 제시한 공을 인정받는 데 미련을 두지 않는다.

## 자기 절제: 두 번재 시스템 효과

두 번째 시스템에 대한 일반적인 경향은, 첫 번째를 만들면서 조심스레 한편으로 밀쳐두었던 온갖 아이디어와 장식을 도입하여 설계가 과도해진다는 것이다.

두 번째 시스템 효과는 순수하게 기능적인 장식과는 조금 차이가 나는 또 다른 징후도 보여준다.

시스템이 끼치는 유별난 위험을 자각하고, 기능적인 장식을 더 하는 일, 전제와 목적의 변경으로 불필요해진 기능을 확장하는 일을 삼가도록 스스로를 자제시킬 수는 있을 것이다.

아키텍트의 눈을 뜨게 하는 훈련으로, 세부 기능 하나하나에 값을 부여하는 방법이 있다.

최소 두 개의 시스템을 개발한 경험이 있는 사람을 선임 아키텍트로 고수해야 한다.

자신이 세운 철학과 목적이 세세한 설계 속에 완전히 반영되도록 하기 위한 올바른 질문을 던질 수 있을 것이다.

# 6장 말을 전하다

## 문서화된 명세: 매뉴얼

매뉴얼은 제품에 대한 `외주적인`명세로, 사용자가 보게 되는 모든 세부 사항을 기술하고 규정한다. 따라서 이것은 아키텍트의 가장 중요한 산물이다.

매뉴얼은 인터페이스를 비롯해서 사용자가 보는 모든 것을 기술해야 한다.

사소한 결정 사항들이 매뉴얼의 처음부터 끝까지 일관되어야 한다는 원칙은 사소한 것이 아니다.

정밀함은 매뉴얼 작성자라면 누구든 동경하는 경지이며, 이 수준에 이르려면 무엇이 규정되는지만이 아니라 무엇이 규정되지 않는지도 주의 깊게 정의해야 한다.

## 형식적 정의

형식적 정의의 장단점

- 장점: 정확하다.
- 단점: 이해하기 쉽지 않다.

명세 작성에는 형식적 정의와 서술적 정의가 모두 쓰이리라 생각한다. 두 가지가 같이 쓰인다면 둘 중 하나가 기분이 되고 다른 하나는 보조적인 역할이어야 하며, 이런 점은 명확히 드러나야 한다.

형식적 정의에 관련된 도구

- 프로그래밍 언어: 베커스-나우르 표기법

## 직접 포함하기

먼저 전달될 인자나 공유 저장소에 대한 선언부를 설계하고, 그 선언부를 구현체가 매크로 또는 PL/I의 %INCLUSE 같은 컴파일 타임 기능을 서서 포함하도록 하는 것이다.

## 회의와 법정

말할 것도 없이 회의는 필요하다.

회의의 두 단계

1. 모든 아키텍트가 모이는 반나절 가량의 주간 회의
2. 사소한 항의나 공개된 현안, 불만 사항들을 담아준 백로그를 정기라기 위한 법정

## 여러 벌 구현하기

처음부터 구현체를 두 개 이상 만든다면, 언어의 정의는 더 깔끔해지고 질서도 좀 더 잡힐 것이다.

## 통화 일지

구현이 진행됨에 따라 설계상의 해석에 관한 질문이 수도 없이 생기게 된다. 이것은 명세의 명확한 정도와는 무관하다.

모든 질문과 답변 내용을 기록해 두는 것이다. → 슬랙으로 물어보고 슬랙 스레드에 기록이 남는다.

## 제품 테스트

프로젝트 관리자의 가장 좋은 친구는 제품 테스팅 조직이다.

고객이 독립된 감사인이며, 실제 사용이라는 가차 없는 빛 아래 모든 결함은 드러날 것이다.

테스팅 조직은 설계 내용의 전달 계통에 필수적인 연결 고리이며, 설계와 동시에 초반부터 가동될 필요가 있다.
