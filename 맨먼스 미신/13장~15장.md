# 13장 전체 그리고 부분들

## 버그를 줄이는 설계

**버그를 방지하는 정의.** 버그 중에서 가장 치명적이고 찾기 힘든 부류는, 다양한 구성 요소의 개발자들이 나름대로 세운 가정이 서로 어긋날 때 생기는 시스템 버그들이다.

개념적 일관성이 있는 제품은 사용하기 쉬울 뿐 아니라 만들기도 쉽고 버그가 생길 가능성도 줄어든다.

> 결정적인 중대 과제는 제품을 정의하는 것이다. 수없이 많은 실패가 제대로 정의하지 않음에서 비롯된다.

**명세 테스트.** 코드가 한 줄이라도 만들어지기 훨씬 전부터, 명세의 외부 테스팅 그룹으로 넘겨져서 완전성과 명확성을 검토받아야 한다.

**하향식 설계.** 설계라는 것은 일련의 `세분화 단계들`로 파악한다. 우선 주요한 결과를 달성하도록 대략의 작업을 정의하고 해결 방법을 스케치한다. → MVP?

다음에는 정의했던 내용을 더욱 면밀히 검토하면서 그 결과가 바라는 바와 어떤 차이가 있는지 살피고, 해결 방법의 큰 단계들을 좀 더 작은 단계들로 나누어간다.

작업 정의를 세분화함에 따라 해법을 담은 알고리즘도 점차 세분화되며, 그 과정에서 데이터 표현법 또한 세분화 될 수 있다.

이런 과정에서 해법이나 데이터 내의 `모듈`들이 드어나게 되는데 각 모듈은 다른 작업과 무관하게 각각 세분화해 나갈 수 있다.

좋은 하향식 설계는 여러 면에서 버그를 회피하도록 해준다.

1. 프로그램 구조와 데이터 표현법이 명확해 각 모듈의 요구 사항과 기능을 엄밀하게 기술하기 더 쉽다.
2. 서로 독립적인 모듈로 분할함으로써 시스템 버그가 예방된다.
3. 세부 내용을 숨김에 따라 구조상 결함이 있을 경우 눈에 더 잘 띄게 된다.
4. 각 세분화 단계마다 설계를 테스트할 수 있으므로 테스트를 더 일찍 시작할 수 있고, 단계마다 그게 맞는 수준의 세부 사항에 집중할 수 있다.

**구조적 프로그래밍.**

중요한 것, 즉 버그 없는 프로그램을 만드는 데 필수적인 것은, 시스템의 제어 구조를 개별적인 분기분이 아니라 그야말로 제어 구조로 생각해야 한다는 점이다. 이와 같은 사고방식이 앞으로 한 발 나아가는 큰 걸음이 된다.

## 구성 요소 디버깅

- 온-머신 디버깅
- 메모리 덤프
- 스냅샷
- 대화식 디버깅
- 테스트 케이스

## 시스템 디버깅

- 디버깅된 구성 요소를 사용하라.
  - 통상적인 관례까지는 아니지만 상식적으로 생각할 때 시스템 디버깅은 각 부분이 제대로 동작하게 된 다음에 시작하는 것이 타당하다.
- 비계를 많이 만들라.
  - 여기서 비계라고 함은, 디버깅 목적으로 만들어졌지만, 최종 제품에 포함될 일은 전혀 없는 프로그램과 데이터를 말한다.
- 변경을 통제하라.
  - 테스트 도중 엄격한 통제는 하드웨어 디버깅에서 볼 수 있는 인상적인 기법인데, 이것은 소프트웨어 시스템에도 적용할 수 있다.
  - 제품이라 할 수 있는 `문서`에 대한 엄격한 통제와 깊은 존중이 절실히 필요하다. 이 기법에서 중요한 요소는 모든 변경 사항을 일지에 기록해 두는 것, 그리고 충분한 검토와 테스트와 문서화를 거친 수정 사항과 응급조치 간의 차이점을 소스 코드상에 두드러지도록 구분해 두는 것이다.
- 구성 요소 추가는 한 번에 하나씩.
- 변경은 묶음으로.

# 14장 재앙의 알을 품다

재앙의 원인은 대개 토네이도라기보다 흰개미 때문일 경우가 많다.

매일매일 조금씩 일어나는 지연은 더 알아차리기 어렵고, 예방하기도 어려우며, 만회하기도 더 힘들다.

## 마일스톤인가, 맷돌인가?

첫걸음은 일정을 잡는 것부터 시작된다. 일정의 이벤트 목록에 기재된 각 항목은 마일스톤이라 부르며, 목표 날짜가 부여된다.

마일스톤의 선택에는 오직 하나의 규칙만이 의미를 가진다. 마일스톤은 구체적이고 명확하고 측정 가능한 이벤트여야 하며, 날이 선 듯이 분명하게 정의되어야 한다.

마일스톤이 너무나 분명해서 스스로를 속일 수 없을 정도라면, 진행 상황에 대해 거짓을 말하기는 쉽지 않다.

흥미로운 연구 결과

1. 어떤 활동의 소요 시간은 화동 개시 전에 추정되어 2주마다 신중하게 변경되었다. 추정치는 시작 시기가 다가와도 크게 바뀌지 않았는데, 이런 양상은 추정의 정확도와 무관했다.
2. 과대 평가된 추정치는 활동이 진행됨에 따라 도중에 그 값이 꾸준히 떨어졌다.
3. 과소 평가된 추정치는 활동 도중에 애초 예정된 종료 시점 3주 전까지 큰 변동이 없었다.

마일스톤은 실제로는 팀에 대한 봉사이며, 관리자로부터 정당하게 기대할 수 있는 것이다. 불분명한 마일스톤은 일을 진행할 때 더 힘겨운 짐이 된다.

## 어차피 다른 쪽도 늦었을걸

허슬은 팀이 완충을 위한 예비 역량을 갖추게 해서, 일상적인 불상사에 대처하고 덜 심각한 재난을 내다보며 대비하도록 해준다.

## 덮어 둔 것들

보수들은 두 종류의 정보가 필요하다. 계획에 차질을 가져와서 조치가 필요한 문제들, 그리고 상황 파악을 위한 프로젝트의 전체 모습이 그것이다.

일선 관리자는 자신이 문제를 보고했을 때 상사가 거기에 대해 조치를 취하는 것을 두려워한다. 그렇게 할 때 상사의 조치는 관리자의 일을 가로챌 것이고, 자기 권위는 떨어지며, 다른 계획들도 엉망이 될 것이다.

이런 경우 보스에게는 약탄자를 들출 방법이 두 가지 있으며 둘 다 사용해야 한다.

1. 역할 갈등을 줄이고 상황 공유를 장려하는 것
2. 양탄자를 다시 홱 젖히는 것

### 역할 갈등 줄이기.

보스는 우선 행동이 필요한 정보와 상황 파악을 위한 정보를 구별해야 한다. 그는 부하 관리자들이 해결할 수 있는 문제는 나서지 않도록 한다. 절대 행동을 취하지 않도록 스스로 자제해야 한다.

반대로, 보스가 당황하거나 역할을 가로채는 일 없이 상황 보고를 받아들이는 것이라는 점을 알고 있다면, 일선 관리자는 솔직한 평가를 올리게 된다.

보스가 각종 회의와 회고를 `상황 점검`과 `문제 해결`로 나누고 거기에 맞춰 스스로를 통제한다면 이 모든 과정에 도움이 된다.

### 양탄자 젖히기.

그 과정이 협조적이든 아니든 간에, 실제 상황을 있는 대로 알기 위한 점검 기법을 동원하는 일 역시 필요하다.

프로젝트 관리자는 추정된 날짜에는 손을 대지 말고, 최일선 관리자들이 구미에 맞는 낙관적 수치나 방어를 위한 보수적 수치가 아닌 정확하고 치우침 없는 추정치를 얻도록 강조해야 한다.

# 15장 또 다른 면

이제 이 글의 남은 부분에서는 문서화를 잘해야 한다고 권고하기보다 `어떻게` 문서화를 잘하느냐에 집중한다.

## 어떤 문서들이 필요한가?

### 프로그램 사용하기

쓸모 있는 상세 설명을 작성하려면, 뒤로 한 발 물러난 다음 찬찬히 들여다봐야 한다.

### 프로그램 신뢰하기.

프로그램이 어떻게 사용되는가 하는 것은, 제대로 동작하는지 어떻게 알 수 있는가에 대한 내용으로 보충되어야 한다. 이것은 테스트 케이스를 의미한다.

### 프로그램을 수정하기.

프로그램을 개작하거나 고치기 위해서는 상당량의 정보가 더 있어야 한다.

## 순서도의 저주

순서도는 프로그램 문서화 중에서도 가장 과대 선전된 기법이다. 대개는 순서도 자체가 전혀 필요하지 않고, 한 페이지를 넘는 순서도가 필요한 경우가 드물다.

결국 프로그램 구조와 단계들을 표현한 다이어그램이 되며, 이것은 상당히 유용하다.

상세한 순서도는 사실 한물간 폐단이며, 초보자들에게 알고리즘적 사고를 가르칠 때나 유용한 것이다.

우리에게 순서도의 효용성에 대해 무언가를 가르쳐주고 있다고 본다.

## 자체 문서화 프로그램

프로그램 문서화는 빈약함으로 악명 높으며 그 문서의 유지 관리는 더 심각하다. 프로그램의 변경 사항이 문서에 즉시, 정확하게, 빠짐없이 반영되는 일을 보기 힘들다.

파일을 합쳐서 문서 내용이 프로그램 소스에 포함되게 하는 것이다. 이것은 그 즉시로 문서의 유지 관리를 제대로 해야 할 강력한 동기가 되고, 프로그램의 문서화가 언제나 사용자 손 닿는 곳에 있음을 보장한다. 이것을 `자체 문서화` 프로그램이라 칭한다.

우리는 문서화에 대한 부담, 즉 우리 자신과 전임자들도 제대로 짊어질 수 없었던 그런 부담을 최소화하고자 시도해야 한다.

### 접근 방법

1. 문서화할 내용을 최대한 많이 포함시킬 목적으로, 프로그램 언어의 특성상 어차피 있어야 할 부분들을 이용하자는 것이다.
2. 가독성을 높이고 종속과 내포 구조를 드러내기 위해 공백과 서식을 최대한 활용하는 것이다.
3. 상세한 문서화의 내용을 프로그램 안에 단락 형태의 주석문으로 삽입하는 것이다.

### 도입하지 않을 이유

가장 심각한 반대 이유는 저장할 소스 코드 크기의 증가다.
