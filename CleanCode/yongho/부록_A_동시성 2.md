# 클라이언트/서버 예제

먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다. 가능성은 다음 두 가지다. 

- I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등에 시간을 보낸다.
- 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보낸다.

대개 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 대개 하나가 지배적이다. 만약 프로그램이 주로 프로세서 연산에 시간을 보낸다면, 새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다. 프로세서 연산에 시간을 보내는 프로그램은 스레드를 늘린다고 빨라지지 않는다. CPU 사이클은 한계가 있기 때문이다.

- 프로그램이 주로 I/O 연산에 시간을 보낸다면 동시성이 성능을 높여주기도 한다.
- 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 놀고 있는 CPU를 효과적으로 활용할 수 있다.

### 서버 살펴보기

서버 코드가 지는 책임은 아래와 같다.

- 소켓 연결 관리
- 클라이언트 처리
- 스레드 정책
- 서버 종료 정책

다중 스레드 프로그램을 깨끗하게 유지하려면 잘 통제된 몇 곳으로 스레드 관리를 모아야  한다. 

스레드를 관리하는 코드는 스레드만 관리해야 한다. 

→ 비동시성 문제까지 뒤섞지 않더라고 동시성 문제는 그 자체만으로도 추적하기 어려운 탓이다. 

### 심층 분석

원자적 연산 `atomic operation`이란 무엇일까? 위는 중단이 불가능한 연산을 원자적 연산으로 정의한다.

### 결과

어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다. 

- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법

## 라이브러리를 이해하라

### 다중 스레드 환경에서 안전하지 않은 클래스

본질적으로 다중 스레드 환경에서 안전하지 않은 클래스가 있다.

- SimpleDateFormat
- 데이터베이스 연결
- java.util 컨테이너 클래스
- 서블릿

## 메서드 사이에 존재하는 의존성을 조심하라

### 실패를 용인한다.

한밤중에 시스템을  재부팅해 메모리 누수를 해결하는 방법과 비슷하다. 

### 클라이언트-기반 잠금

서버를 사용하는 모든 프로그래머가 락을 기억해 객체에 걸었다 풀어야 하므로 다소 위험한 전략이다.

### 서버-기반 잠금

일반적으로 서버-기반 잠금이 더 바람직하다. 

- 코드 중복이 줄어든다.
- 성능이 좋아진다.
- 오류가 발생할 가능성이 줄어든다.
- 스레드 정책이 하나다.

## 작업 처리량 높이기

동기화 여역은 언제나 작을수록 좋다.

### 작업 처리량 계산 - 단일스레드 환경

- 페이지를 읽어오는 평균 I/O 시간: 1초
- 페이지를 분석하는 평균 처리 시간: 0.5초
- 처리는 CPU 100% 사용, I/O는 CPU 0% 사용

스레드 하나가 N 페이지를 처리한다면 총 실행 시간은 1.5초 * N이다. 

### 작업 처리량 계산 - 다중 스레드 환경

순서에 무관하게 페이지를 읽어와 독립적으로 처리해도 괜찮다면 다중 스레드가 처리율을 높여줄지 모른다.

## 데드락

네 가지 조건을 모두 만족하면 데드락이 발생한다. 

- 상호 패배
- 잠금 & 대기
- 선점 불가
- 순환 대기

### 상호 배제

여러 스레드가 한 자원을 공유하나 그 자원이 아래와 같은 조건을 만족하면 상호 배제 조건을 만족한다.

- 여러 스레드가 동시에 사용하지 못한다.
- 개수가 제한적이다.

좋은 예가 데이터베이스 연결, 쓰기용 파일 열기, 레코드 락, 세마포어 등과 같은 자원이다.

### 잠금 & 대기

일단 스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다. 

### 선점 불가

한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다. 자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 점유하지 못한다.

### 순환 대기

죽음의 포옹이라고도 한다.

### 상호 배제 조건 깨기

데드락을 피하는 전략 중 하나가 상호 배제 조건을 비껴가는 방법이다.

- 동시에 사용해도 괜찮은 자원을 사용한다.
- 스레드 수 이상으로 자원 수를 늘린다.
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.

### 잠금 & 대기 조건 깨기

대기하지 않으면 데드락이 발생하지 않는다. 각 자원을 점유하기 전에 확인한다. 만약 어느 하나라도 점유하지 못한다면 지금까지 점유한 자원을 몽땅 내놓고 처음부터 다시 시작한다. 

이 방법의 문제점

- 기아: 한 스레드가 계속해서 필요한 자원을 점유하지 못한다. 점유하려는 자원이 한꺼번에 확보하기 어려운 조합일지도 모른다.
- 라이브락: 여러 스레드가 한꺼번에 잠금 단계로 진입하는 바람에 계속해서 자원을 점유했다 내놓다를 반복한다.

두 경우 모두가 자칫하면 작업 처리량을 크게 떨어트린다. 

### 선점 불가 조건 깨기

다른 스레드로부터 자원을 뺏어오는 방법. 일반적으로 간단한 요청 매커니즘으로 처리한다. 필요한 자원이 잠겼다면 자원을 소유한 스레드에게 풀어달라 요청한다. 소유 스레드가 다른 자원을 기다리던 중이었다면 자신이 소유한 자원을 모두 풀어주고 처음부터 다시 시작한다.

### 순환 대기 조건 깨기

데드락을 방지하는 가장 흔한 전략. 

모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능하다. 

문제점

- 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다.
- 때로는 순서에 따라 자원을 할당하기 어렵다.

## 다중 스레드 코트 테스트

- 몬테 카를로 테스트: 조율이 가능하게 유연한 테스트를 만든다. 그런 다음, 임의로 값을 조율하면서 반복해 돌린다. 테스트가 실패하면 버그가 있다는 증거다. 테스트는 일찌감치 작성하기 시작해 통합 서버에서 계속 돌린다. 참고로, 테스트가 실패한 조건은 신중하게 기록한다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다. 반복해서 돌린다. 계속 해서 돌린다. 테스트가 실패 없이 오래 돌아갈수록 두 가지 중 하나일 확률이 높아진다.
    - 실제 코드가 올바르다.
    - 테스트가 부족해 문제를 드러내지 못한다.
    - 부하가 변하는 장비에서 테스트를 돌린다.

## 스레드 코드 테스트를 도와주는 도구

- ConTest: 스레드에 안전하지 않은 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구다.
- 실제 코드와 테스트 코드를 작성한다. 다양한 부하 상황에서 여러 사용자를 시뮬레이션하는 테스트도 빼놓지 않는다.
- ConTest로 실제 코드와 테스트 코드에 보조 코드를 추가한다.
- 테스트를 실행한다.