# 코드가 존재하리라

앞으로 코드가 사라질 가망은 전혀 없다! 코드는 요구사항을 상세히 표현하는 수단이다. 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능하다. 추상화도 불가능하다. 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업이 프로그래밍이다. 이렇게 명시한 결과가 바로 코드다.

우리가 요구사항 명세 분야에서 배운 교훈이라면, 제대로 명시한 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋다는 사실이다.

궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다. 요구사항에 더욱 가까운 언어를 만들 수도 있고, 요구사항에서 정현 구조를 뽑아내는 도구를 만들 수도 있다. 하지만 어느 순간에는 정밀한 표현이 필요하다. 그 필요성을 없앨 방법은 없다. 그러므로 코드도 항상 존재하리라.

# 나쁜 코드

회사가 망한 원인은 바로 나쁜 코드 탓이었다.

다시 돌아와 나중에 정리하겠다고 다짐했었다. 물론 그때 그 시절 우리는 르블랑의 법칙을 몰랐다. `나중은 결코 오지 않는다`→ 항상 개발을 하면서 일어납니다. 생각하지 못한 부분에서 문제가 발생하거나 막상 작업을 하니 예상했던 크기보다 크거나 그렇게 추정에 실패하고 작업을 마무리하게 됩니다.

# 나쁜 코드로 치르는 대가

간단한 변경은 없다. 매번 얽히고설킨 코드를 해독해서 얽히고설킨 코드를 더한다. 시간이 지나면서 쓰레기 더미는 점점 높아지고 깊어지고 커진다. 청소할 방법이 없다. 불가항력이다. → 일정 시간을 투입해서 청소하는 시간을 갖게 된다면 어떨까요? 남이 싼 똥을 치우는 것보다 내가 싼 똥을 치우는 것이 덜 억울하잖아요?

나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러다가 마침내 0에 근접한다. 그러면 관리층에서는 더 많은 개발자를 투입하게 되고 새 인력들은 시스템 설계에 대한 조예가 깊지 않아 설계 의도에 맞는 변경과 설계 의도에 반하는 변경을 구분하지 못한다. 또한 생산성을 높여야 한다는 극심한 압력에 시달려 결국 더 나쁜 코드를 더 많이 양산하게 된다.

## 원대한 재설계의 꿈

이렇게 추가된 개발 인원은 혐오스러운 코드에서 일하지 못하겠다고 하며 관리층에게 재설계를 요구한다. 관리층은 재설계에 자원을 쏟아붓기 싫지만 생산성이 바닥이라 결국 팀이 요구하는 대로 원대한 재설계를 허락한다.

하지만 새로운 팀은 기존 시스템의 기능을 100% 지원하고 새로운 요구사항을 반영하는 새 시스템을 내놓아야 한다. 이러한 작업은 때때로 오랫동안 이어진다. 그렇게 되면 초창기 팀원이 나가고 새로운 팀원이 들어오고 다시 새 시스템을 설계하자고 나선다 왜? 현재 시스템이 너무 엉망이라서. → 이러한 과정이 일반적인 이야기군요. 새로운 사람이 기존 시스템과 코드에 대해서 욕하고 하길래 새로운 사람이 잘하는 사람이고 기존의 코드를 작성한 사람은 못하는 사람이라고 생각했습니다.

## 태도

좋은 코드가 어째서 순식간에 나쁜 코드로 전락할까? → 왜 그럴까!!

잘못은 전적으로 우리 프로그래머에게 있다. 우리는 프로젝트를 계획하는 과정에 깊숙이 관여한다. 그러므로 프로젝트 실패는 우리에게도 커다란 책임이 있다. 특히 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다. → 제가 작성한 코드니까 저의 잘못이지요.

좋은 코드를 사수하는 일은 바로 우리 프로그래머들의 책임이다. → 알고 있다고요!

나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르는 행동은 전문가답지 못하다. → 그대로 따르진 않는다고요. 하지만 VOC 계속들어오고 기획은 없고 제품의 방향이 없이 진행은 되어 기존 제품 기능에서 코드는 꼬이고…쓰레기 코드가 내 손 끝에서 시작됩니다.

## 원초적 난제

프로그래머는 근본적인 가치에서 난제에 봉착한다.

프로그래머라면 누구나 나쁜 코드가 업무 속도를 늦춘다는 사실을 익히 안다. 그럼에도 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수밖에 없다고 느낀다. 간단히 말해, 그들은 빨리 가려고 시간을 들이지 않는다.

진짜 전문가는 두 번째 부분이 틀렸다는 사실을 잘 안다. 나쁜 코드를 양산하면 기한을 맞추지 못한다. 오히려 엉망진창인 상태로 인해 속도가 곧바로 늦어지고, 결국 기한을 놓친다.

기한을 맞추는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

## 깨끗한 코드라는 예술?

깨끗한 코드를 구현하는 행위는 그림을 그리는 행위와 비슷하다. 그림을 보면 대부분의 사람은 잘 그려졌는지 엉망으로 그려졌는지 안다. 그렇지만 잘 그린 그림을 구분하는 능력이 그림을 잘 그리는 능력은 아니다.

다시 말해, 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다.

깨끗한 코드를 작성하려면 `청결`이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 절제와 규율이 필요하다.

열쇠는 `코드 감각`이다. `코드 감각`이 있으면 좋은 코드와 나쁜 코드를 구분하고 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.

`코드 감각`이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다. `코드 감각`으로 최고 방안을 선택한 후 여기서 거기까지 이동하는 경로를 계획한다.

깨끗한 코드를 작성하는 프로그래머는 빈 캔버스를 우아한 작품으로 바꿔 가는 화가와 같다.

## 깨끗한 코드란?

> 나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에 의해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를 제대로 한다.

- 비아네 스트롭스트룹, C++ 창시자
  >
- 깨끗한 코드는 ’보기에 즐거운‘코드다.
- 철저한 오류 처리
- 세세한 사항까지 꼼꼼하게 처리하는 코드
- 깨끗한 코드는 한 가지를 잘한다.

> 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와 단순한 제어문으로 가득하다.

- 그래디 부치
  >
- 가독성이 좋아야 한다.
- 해결할 문제의 긴장을 명확히 드러내야 한다.

> 깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다. 단위 테스트 케이스와 인수 테스트 케이스가 존재한다. 깨끗한 코드에는 의미 있는 이름이 붙는다. 특정 목적을 달성하는 방법은 하나만 제공한다. 의존성은 최소이며 각 의존성을 명확히 정의한다. API는 명확하며 최소로 줄였다. 언어에 따라 필요한 모든 정보를 코드만으로 명확히 표현할 수 없기에 코드는 문학적으로 표현해야 마땅하다.

- 데이브 토마스
  >
- 가독성이 좋아야한다.
- 깨끗한 코드란 다른 사람이 고치기 쉽다고 단언한다.
- 실제로 읽기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다.
- 테스트 코드가 있어야 한다.
- 큰 코드보다 작은 코드에 가치를 둔다.

> 깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나 있다. 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로. 고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 그리고 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.

- 마이클 페더스
  >
- 한 마디로 요약하면 ’주의‘다.
- 코드를 주의 싶게 작성한다.
- 깨끗한 코드는 주의 깊게 작성한 코드다.

> 모든 테스트를 통과한다.
> 중복이 없다.
> 시스템 내 모든 설계 아이디어를 표현한다.
> 클래스, 메서드, 함수 등을 최대한 줄인다.

- 존 제프리스
  >
- 한 기능만 수행하라.
- 제대로 표현하라.
- 작게 추상화하라

> 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불려도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불려도 되겠다.

- 워드 커닝햄
  >

# 우리들 생각

1. 깨끗한 변수 이름
2. 깨끗한 함수
3. 깨끗한 클래스

이 책은 우리 `오브젝트 멘토 진영이 생각하는 깨끗한 코드`를 설명한다.

# 우리는 저자다

javadoc에서 @author 필드는 저자를 소개한다. 저자에게는 독자와 잘 소통할 책임도 있다.

우리는 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.

# 보이스카우트 규칙

잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 시간이 지나면서 엉망으로 전략하는 코드가 한둘이 아니다. 그러므로 우리는 적극적으로 코드의 퇴보를 막아야 한다.

한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다. 변수 이름 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중보를 제거하고 복잡한 if 문 하나를 정리하면 충분하다. → 보이스카우트 규칙을 수행하는 것은 일정 시간을 투자해서 깨끗하게 만들어야 한다고 생각했는데 부담감이 많이 줄었습니다.

# 프리퀄과 원칙

SRP, OCP, DIP

# 결론

예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. → 크으 이 책을 읽으며 조금 더 발전한 개발자가 되기를 희망하고 있었는데 😓 이걸 1장에 이렇게 빠져나가다니!

> 연습해 연습!

# 느낀점

깨끗한 코드는 어떤 코드일까? 에 대한 물음에 대해 유명한 개발자의 말은 이용해 그 방향에 대해 설명을 해주고 있어서 인상적이었습니다. 마지막에 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다며 슬쩍 발을 빼며 바이올린 연주자와 노인의 이야기에서 저에게 연습하라고 이야기하는데 역시 지름길은 없나 봅니다.
