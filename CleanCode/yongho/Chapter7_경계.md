오류 처리는 프로그램에 반드시 필요한 요소 중 하나일 뿐이다.

상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다.

여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미다.

오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.

# 토론

이번 장에서 언급한 내용으로 오류를 처리한 경험을 이야기 해봐요. 

저의 경우는 워크스테이션을 유지보수할 때는 서버측에서 확인된 오류 코드를 지정해주고 서버 api에서 오류 코드를 내려주는 방식으로 작업을 했었습니다. 

그래서 `axios` 인스턴스에 오류 코드를 모두 작성하고 오류 메시지를 작성하고 사용자에게 바로 보여주는 방식이었습니다. 

확인된 오류 코드가 떨어지면 오류 파악이 쉬웠지만

그렇지 않은 오류 코드는 9999 이런식으로 떨어지는 바람에 문제 파악에 어려웠던 경험이 있습니다. 

# 오류 코드보다 예외를 사용하라

오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 더 깔끔해진다.

논리가 오류 처리 코드와 뒤섞이지 않으니까

```jsx
public class DeviceController {
	public void sendShutDown () {
		try {
			tryToShutDown();
		} catch (DeviceShutDownError e) {
			logger.log(e);
		}
	}

private void tryToShutDown () throws DeviceShutDownError {
	DeviceHandle handle = getHandle (DEV1);
	DeviceRecord record = retrieveDeviceRecord (handle);
	
	pauseDevice (handle);
	clearDeviceWorkQueue(handle);
	closeDevice (handle);
}

//...
```

# Try-Catch-Finally 문부터 작성하라

try 블록은 트랜잭션과 비슷하다.

try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.

예외기 발생할 코드를 잘 때는 try-catch-finally 문으로 시작하는 편이 낫다. 

```jsx
public List<RecordedGrip> retrieveSection (String sectionName) {
	try {
		FileInputStream stream = new FileInputStream(sectionName) ;
		stream.close ();
	} catch (FileNotFoundException e) {
		throw new StorageException ("retrieval error", e);
		return new ArrayList<RecordedGrip>();
	}
```

catch 블록에서 예외 유형을 좁힌다.

try-catch 구조로 범위를 정의했으므로 TDD를 사용해 필요한 너머지 논리를 추가

자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.

# 미확인 예외를 사용하라

확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 철저히 따져봐야 한다.

확인된 예외는 OCP(open closed principle)를 위반한다.

하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다. 

최하위 함수에서 throws를 던지면 최상위 단계까지 연쇄적인 수정이 필요하다. 

최하위에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다. 

확인된 예외가 캡슐화를 깨버리는 현상이 생긴다.

일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다. 

# 예외에 의미를 제공하라

예외를 던질 때는 전후 상황을 충분히 덧붙인다. 

오류가 발생한 원인과 위치를 찾기가 쉬워진다.

오류 메시지에 정보를 담아 예외와 함께 던진다.

실패한 연산 이름과 실패 유형도 언급한다.

애플리케이션이 로깅 기능을 사용한다면 catch 블록에서 오류를 기록하도록 충분한 정보를 넘겨준다.

# 호출자를 고려해 예외 클래스를 정의하라

애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 **오류를 잡아내는 방법**이 되어야 한다. 

대다수 상황에서 우리가 오류를 처리하는 방식은 일정하다. 

1. 오류를 기록한다.
2. 프로그램을 계속 수행해도 좋은지 확인한다. 

외부 API를 사용할 때는 감싸기 기법이 최선이다.

외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 

- 다른 라이브러리로 교체하는 비용이 적다.
- 흔히 예외 클래스가 하나만 있어도 충분한 코드가 많다.

# 정상 흐름을 정의 하라

비즈니스 논리와 오류 처리 분리

오류 감지가 프로그램 언저리로 밀려나는 경우가 생길 수 있다.

클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식: 특수 사례 패턴

클래스나 객체가 예외적인 상황을 캡슐화해서 처리

# null를 반환하지 마라

null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.

누구 하나라도 null 확인을 하지 않는다면 애플리케이션이 통제 불능에 빠진다.

null을 반환하고픈 유혹이 든다면 그 대신에 예외를 던지거나 특수 사례 객체를 반환한다.

외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려

많은 경우에 특수 사례 객체가 손쉬운 해결책이다.

# null을 전달하지 마라

매서드에서 null을 반환하는 방식도 나쁘지만, 메서드로 null을 전달하는 방식은 더 나쁘다.

정상적인 인수로 null을 기대하는 api가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다. 

# 결론

깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.