# TDD 법칙 세가지

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 
3. 현재 실패하는 테스트를 통과할 정도만 실제 코드를 작성한다.

세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다. 

테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.

실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발한다. 

# 깨끗한 테스트 코드 유지하기

일회용 테스트 코드를 짜오다가 새삼스레 자동화된 단위 테스트 슈트를 짜기란 쉽지 않다.

지저분한 테스트 코드는 없는 것이 낫다.

- 변경하기 어려워진다.
- 새로 추가하는 데 시간이 더 걸린다
- 유지비용 비용이 늘어난다.
- 개발자 사이에서 불만이 생긴다.

테스트 슈트가 없으면 아래와 같은 상황이 생긴다. 

- 수정한 코드가 제대로 도는지 확인할 방법이 없다.
- 시스템 수정 후 안전하다는 사실을 검증하지 못한다.
- 결함율이 높아진다.
- 의도하지 않은 결함이 늘어나 변경을 주저한다.
- 코드를 정리하지 않는다.

테스트 코드는 실제 코드 못지않게 중요하다.  

→ 결국엔 이렇게 관리 안 된 테스트 코드도 관리 안 된 주석과 같은 악의 축 역할을 하게 되는 것이군요?

## 테스트는 유연성, 유지보수성, 재사용성을 제공한다.

테스트 케이스가 있으면 변경이 두렵지 않다. 

테스트 케이스가 없다면 모든 변경이 잠정적인 버그다.

테스트 커버리지가 높을수록 공포는 줄어든다. 

오히려 안심하고 아키텍처와 설계를 개선할 수 있다.

# 깨끗한 테스트 코드

1. 가독성
2. 가독성
3. 가독성

가독성을 높이려면 명료성, 단순성, 풍부한 표현력이 필요하다.

BUILD-OPERATE-CHECK

1. 테스트 자료를 만든다.
2. 테스트 자료를 조작한다.
3. 조작한 결과가 올바른지 확인한다.

테스트 코드는 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다. 

## 도메인에 특화된 테스트 언어

테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다.

## 이중 표준

실제 환경과 테스트 환경은 요구사항이 판이하게 다르다.

실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다. 

대개 메모리나 CPU 효율 관련 있는 경우다.

코드의 깨끗함과는 철저히 무관하다.

# 테스트 당 assert 하나

assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 

## 테스트 당 개념 하나

테스트 함수마다 한 개념만 테스트하라.

독자적인 개념을 여러 개 가지고 있다면 독자적인 테스트로 쪼개야 마땅하다.

# F.I.R.S.T.

**빠르게**, **Fast**: 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다. 

**독립적으로, Independent:** 각 테스트는 서로 의존하면 안 된다. 

반복가능하게, Repeatable: 어떤 환경에서도 반복 가능해야한다. 

자가검증하는, Self-Validating: 테스트를 부울값으로 결과를 내야 한다.

적시에, Timely: 적시에 작성해야한다. 실제 코드를 구현하기 직전에 구현한다.

→ 실제 코드 작성을 먼저 하면 테스트 코드를 작성하지 않을까봐?

# 결론

테스크 코드는 실제 코드만큼이나 중요하다. 

실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다.

테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 

# 토론

정말 실체 코드를 작성하기 전에 테스트 코드를 작성이 가능한가요? 적어도 실제 코드를 어떻게 작성하겠다. 라는 계획을 세우고 테스트 코드를 작성하고 실제 코드를 작성해야 하지 않을까? 생각이 듭니다.

실제 코드를 작성하고 테스트 코드를 작성하는 것과 테스트 코드를 먼저 작성하고 실제 코드를 작성하는 것이 차이가 있을까요?