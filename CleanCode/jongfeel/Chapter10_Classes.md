## 10장 클래스

```
논의내용)
객체 지향에 대해 저자가 중요하다고 생각하는 원칙들이 소개 되고 있다.

이런 원칙에 입각한 클래스 설계를 진행해 본 경험이 있는지 얘기해 보면 좋을 듯

---

DIP의 경우는 어떤 정해져 있는 인터페이스의 패턴으로 정착되어서
객체지향을 공부하지 않은 사람들도 프레임워크를 사용하면서 자연스럽게 접하게 되는데
이유를 알고 사용한다면 약간의 코드 수정으로 큰 문제 없이
요구사항의 변경을 적용할 수 있던 경험이 있어서 괜찮은 방법이다.
하지만 실제로 DIP를 만들어서 쓸 생각을 잘 못한다는 것 문제라면 문제일 것이다.
```

좀 더 차원 높은 단계까지 신경써야 하는 부분은 클래스이다.

### 클래스 체계

자바 기준

- 변수 목록
  - 정적 공개 상수
  - 정적 비공개 변수
  - 비공개 인스턴스 변수
  - 공개 변수 (거의 없음)
- 함수 목록
  - 공개 함수
  - 비공개 함수 (공개 함수 직후)

추상화 단계가 순차적으로 내려가므로 신문 기사처럼 읽힌다.

#### 캡슐화

변수와 유틸리티 함수는 되도록 비공개 상태를 유지한다.
같은 패키지 안에서 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면 protected로 선언하거나 패키지 전체로 공개한다.
캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

### 클래스는 작아야 한다!

간결한 클래스 이름이 떠오르지 않는다면 클래스 크기가 커서 그렇다.
클래스 이름에 processor, manager, super 등의 모호한 단어가 있다면 클래스에다 여러 책임을 떠안겼다는 증거다.

#### 단일 책임 원칙

SRP(Single Responsibility Principle)
클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.

SRP는 개념은 객체 지향 설계에서 중요한 개념이다.
또 이해하기 지키기 수월한 개념이다.
그런데도 수많은 책임을 떠안은 클래스를 꾸준하게 접하는 이유는
소프트웨어를 돌아아게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은 완전히 별개이기 때문이다.

```
의견)
경험이 좀 있다면 무슨 말인지 알 수 있는데
돌아가게 만드는 소프트웨어는 프로그래머라면 사실 누구나 만들 수 있기는 한데
그 이상의 이해를 바탕으로 한 개념적인 코드를 작성하는 활동은 쉽지 않기 때문에 그렇다.

특히 SRP 같은 법칙은 꽤나 자주 접하고 그렇게 해야 맞다는 걸 알고 있으면서도
결국 돌아가게 만드는 소프트웨어 그 이상으로 코드가 다듬어지지 않는 이유는
소프트웨어를 잘 만들 생각을 많이 못해서 그런 것 같기도 하다.
```

규모가 어느 수준에 이르는 시스템은 논리가 많고 복잡하다.
이 복잡성을 다루려면 체계적인 정리가 필수다.
큰 클래스는 변경 작업을 할 때 당장 알 필요가 없는 사실까지 알게 하는 방해를 한다.

큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.

#### 응집도

응집도가 높으면 클래스의 메서드와 변수가 서로 의존하며 논리적인 단위로 묶이기 때문에 선호하지만
응집도가 가장 높은 클래스는 바람직하지 않다.
응집도가 적절히 높아지도록 변수와 메서드를 분리해 새로운 클래스로 분리한다.

#### 응집도를 유지하면 작은 클래스 여럿이 나온다

큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다.
그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.

### 변경하기 쉬운 클래스

대다수 시스템은 지속적인 변경이 가해진다.
변경이 일어날 때 마다 시스템이 의도대로 동작하지 않을 위험이 따른다.
깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위협을 낮춘다.

새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.
이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.

#### 변경으로부터 격리

요구사항의 변화에 대응하는 코드를 위해 
인터페이스와 추상 클래스를 사용해 구현에 미치는 영향을 격리한다.

상세한 구현에 의존하는 코드는 테스트가 어렵다.
DIP(Dependency Inversion Priciple)를 따르는클래스를 설계하면
상세 구현이 아니라 추상화에 의존하는 원칙을 따를 수 있다.