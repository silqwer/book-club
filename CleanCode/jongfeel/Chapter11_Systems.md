## 11장 시스템

```
여기서부터는 구현 기법에 대한 것 보다는 전체적인 시스템 구성을 어떻게 하는 게 좋은지 얘기하는 부분이 많다.

한가지 불만은 관심사의 분리 AOP를 설명하는 부분에서 너무 자바와 스프링 프레임워크 의존적인 예제와 설명을 했다는 점이다.  구체적인 구현 레벨은 세부사항일 수 있으니 넘어가 본다.

논의 하고 싶은 내용은 관심사의 분리가 핵심인 내용인데
관심사를 분리 하면서 프로그래밍을 해본 경험을 얘기해 보면 좋을 것 같다.
꼭 관심사 분리를 위한 AOP를 적용한게 아니더라도, 최소한의 interface를 사용해서 의존성 주입 정도만 해도 훌륭한 분리라고 생각한다.

스프링을 사용한 서버 개발을 진행하면서 AOP를 처음 접하게 됐는데
책의 설명 그대로 횡단 관심사에 대해 모듈이나 객체에 일관적으로 적용하는 기법이었다.
만약 다른 서버 도구를 사용하거나 향후 프로젝트를 진행하게 된다면
AOP를 고려해볼 것 같은 좋은 경험이었다. 
```

### 도시를 세운다면

도시에는 큰 그림을 그리는 사람들과, 작은 사항에 집중하는 사람들도 있다.
도시가 돌아가는 또 다른 이유는 적절한 추상화와 모듈화 때문이다.
소프트웨어 팀도 도시처럼 구성한다. 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.

### 시스템 제작과 시스템 사용을 분리하라

제작construction은 사용use과 아주 다르다는 사실을 명심한다.

> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.

관심사의 분리는 가장 오래됐지만 가장 중요한 설계 기법 중 하나이다.

초기화 지연Lazy Initialization 기법은 한 번 정도 사용한다면 별로 심각하지는 않다.
하지만 이런 방식을 많이 사용한다면 모듈성은 저조해지고 중복이 심각해진다.

체계적이고 탄탄한 시스템을 만들고 싶다면 이런 손쉬운 기법으로 모듈성을 깨서는 안된다.
설정 논리는 일반실행 논리와 분리해야 모듈성이 높아진다.  

#### Main 분리

생성과 사용을 분리하는 한 가지 방법으로
생성과 관련된 코드는 모두 main 쪽으로 옮기고
나머지 시스템은 객체가 생성되서 모든 의존성이 연결되었다고 가정한다.

애플리케이션은 main에서 객체가 생성되는 과정을 모른다.
모든 객체는 적절히 생성되었다고 가정한다.

#### 팩토리

객체가 생성되는 시점을 애플리케이션이 결정할 필요가 생기면
추상 팩토리abstract factory 패턴을 사용한다.

#### 의존성 주입

사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입Dependency Injection, DI 이다.
의존성 주입은 제어 역전Inversion of Control, IoC 기법을 의존성 관리에 적용한 메커니즘이다.

대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고,
대부분은 계산 지연이나 팩토리 호출, 프록시 생성 방법을 제공한다.

### 확장

'처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다.
오늘은 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 
내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장한다.
이것이 반복적이고 점진적인 애자일 방식의 핵심이다.

단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수 없는 건 현실이다.

> 소프트웨어 시스템은 물리적인 시스템과 다르다. 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

#### 횡단(cross-cutting) 관심사

영속성과 같은 관심사는 애플리케이션의 자연스러운 객체 경계를 넘나드는 경향이 있다.
원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다.
횡단 관심사는 영속성, 보안, 트랜잭션을 처리하는 방식에서 출발한다.

관점 지향 프로그래밍Aspect-Oriented Programming, AOP는 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론이다.

### 자바 프록시

개별 객체나 클래스에서 메서드 호출을 감싸는 경우에 적합하다.
JDK에서 지원하는 프록시는 인터페이스만 지원한다.
따라서 코드의 양이 많아지고 깨끗한 코드를 작성하기가 어려워진다.
문제는 AOP를 지원하지 않는다는 점이다. 

### 순수 자바 AOP 프레임워크

스프링 AOP, JBoss AOP는 내부적으로 프록시를 사용한다. (AspectJ 제외)
스프링은 비즈니스 논리를 POJO(Plain Old Java Object)로 구현하고 도메인에 초점을 맞춘다.
POJO는 프레임워크나 도메인에 의존하지 않기 때문에 테스트가 개념적으로 더 쉽고 간단하다.

원래 EJB2 코드보다 훨씬 더 깨끗하고, 상세 엔티티 정보는 애너테이션에 포함되어 있다.

### AspectJ 관점

AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
관점을 분리하는 강력하고 풍부한 도구 집합을 제공하지만,
새 도구를 사용하고 새 언어 문법과 사용법을 익혀야 한다는 단점이 있다.

### 테스트 주도 시스템 아키텍처 구축

관점으로 관심사를 분리하는 방식, 코드 수준에서 아키텍처 관심사를 분리할 수 있다면
진정한 테스트 주도 아키텍처 구축이 가능해진다.

소프트웨어 구조가 관점을 효과적으로 분리한다면, 극적인 변화가 경제적으로 가능하다.
결과물을 재빨리 출시하고, 기반 구조를 추가하며 조금씩 확장해 나가는게 가능해진다.

프로젝트는 범위, 목표, 일정 뿐 아니라 시스템의 일반적인 구조도 생각해야 한다.
변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다.

### 의사 결정을 최적화하라

성급한 결정은 불충분한 지식으로 내린 결정이다.
고객 피드백, 프로젝트 고민, 구현 방안 탐험을 위한 기회를 위해서라도
최선의 결정을 내려야 한다.

### 명백한 가치가 있을 때 표준을 현명하게 사용하라

아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례는 만들지 말아야 함

### 시스템은 도메인 특화 언어가 필요하다

DSL(Domain-Specific Language)은 간단한 스크립트 언어나 표준 언어로 구현한 API를 가리킨다.
좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 '의사소통 간극'을 줄여준다. 
도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면 도메인을 잘못 구현할 가능성이 줄어든다.

### 결론

모든 추상화  단계에서 의도는 명확히 표현해야 한다.
POJO를 작성하고 관점을 분리해야 한다.
시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다.