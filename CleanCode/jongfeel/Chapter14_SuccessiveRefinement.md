## 14장 점진적인 개선

```
논의 내용)
리팩터링 과정에 대해 이해하는 사례로 보기에는 좋은데
논의 내용을 끄집어 내기가 어려웠던 것 같다.

그래서 단계적 개선을 위한 리팩터링에 대해 자유롭게 얘기해 보면 어떨까 싶다.
```

점진적인 개선을 보여주는 사례 연구.

명령행 인수 구문을 분석할 필요에 의해서 main 함수에 넘어오는 문자열 배열을 분석할 때 사용하는 유틸리티를 직접 만드는 사례이다.
새로 만드는 유틸리티는 Args라고 부른다.

### Args 구현

ArgumentMarshaler 인터페이스 정의

``` java
public interface ArgumentMarshaler {
    void setIterator<String> currentArgument) throws ArgsException;
}
```

여기서 파생된 클래스는 BooleanArgumentMarshaler, StringArgumentMarshaler 등등이 있고
static T getValue(ArgumentMarshaler am) 멤버로 각 타입에 맞는 getter가 있다.

```
구글에 'clean code args java'라고 쳐도 github의 소스 코드를 확인해 볼 수 있다.
내용 정리에 코드 관련된 부분은 최대한 생략해 본다.
특히 java 버전이 장황하다는 얘기가 있어서 ruby로 짜면 간결해질 수 있다고 했는데 그것도 검색하면 알아볼 수 있다.
```

#### 어떻게 짰느냐고?

한번에 뚝딱 만든게 아니다. 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리하면서 짠다.
수십여년 간 쌓아온 경험에서 얻은 교훈은, 프로그래밍은 과학 보다는 공예Craft에 가깝다는 사실이다.

핵심은 초안에 해당하는 돌아가는 프로그램을 만들고 정리하면서 개선시켜 나갔다는 점이다. 

### Args: 1차 초안

코드는 돌아가지만 엉망인 Args 클래스 예시.
1초안은 명백히 미완성인데 많은 인스턴수 변수 개수, 'TILT'와 같은 희한한 문자열, HashSets와 TreeSets, try-catch-catch 블록 등 지저분한 코드를 만드는 원인이다.

진자 초안인 Boolean만 지원하는 초기 버전은 그렇지 않았다. 
이후 String과 Integer를 추가했을 뿐인데도 코드가 엄청나게 지저분해졌고 코드는 완전히 엉망이 되어버렸다.

#### 그래서 멈췄다

코드 구조를 유지보수하기 좋은 상태로 만들려면 리팩터링이 필요해서 시작했다.

- 인수 유형에 해당하는 HashMap을 선택하기 위해 스키마 요소의 구문을 분석한다.
- 명령행 인수에서 인수 유형을 분석해 진짜 유형으로 변환한다.
- get 메서드를 구현해 호출자에게 진짜 유형을 반환한다.

인수 유형은 다양하지만 유사한 메서드를 제공하므로 ArgumentMarshaler라는 개념이 탄생했다.

#### 점진적으로 개선하다

프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다.

```
의견)
크게 공감하는 부분이고, 개선 자체만 하는 시간을 보내는 것은 오히려 비효율적이라고 생각하는데
코드를 개선하다 보면 구조를 바꾸는 행위를 많이 하게 되고 그러면 설계 변경점에 대한 업데이트도 이루어져야 하는데 그걸 챙기면서 까지 하기에는 큰 일이라 문제가 된다.
```

그래서 TDD를 사용해 언제라도 시스템이 돌아가야 한다는 원칙을 준수해서, 시스템을 망가뜨리는 변경을 허용하지 않게 개선한다.
리팩터링은 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다.

### String 인수

Boolean 인수에 대한 테스트 통과와 리팩터링이 진행 된 후에 유사하게 진행.

...

개선이 어느 정도 이루어졌지만 아래 문제를 더 해결
setArgument에는 유형을 일일이 확인하는 코드가 있고 모든 set 함수가 계속 따라다니는 건 아직 정리할 부분이 많다.
setArgument 함수에서 유형을 일일이 확인하는 코드를 정말로 없애는 작업을 진행 =>
args 배열을 list로 변환한 후 iterator를 set 함수로 전달하는 방식으로 해결

소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다.
적절한 장소를 만들어 코드만 분리해도 설계가 좋아진다.
관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다.

### 결론

돌아가는 코드만으로는 부족하다. 돌아가는 코드가 심하게 망가지는 살계는 흔하다.
단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족하다.
설계와 구조를 개선할 시간이 없다고 변명할 수 있지만 동의하기 어렵다.

나쁜 코드를 깨끗한 코드로 개선할 수 있지만 비용이 엄청나게 많이 든다.
오래된 의존성을 찾아내 깨려면 상당한 시간과 인내심이 필요하다.
하지만 처음부터 코드를 꺠끗하게 유지하기란 상대적으로 쉽다.

코드는 언제나 최대한 깔끔하고 단순하게 정리하자.