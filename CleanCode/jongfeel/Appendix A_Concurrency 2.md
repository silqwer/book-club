## 부록A 동시성 2

이 책에서 소개한 동시성을 좀 더 자세히 설명하고 보완한다.

### 클라이언트/서버 예제

서버는 소켓을 열어놓고 대기
클라이언트는 소켓에 연결해 요청을 보낸다.

#### 서버

클라이언트/서버 - 단일스레드 버전으로 작성

성능 측정을 위해 테스트 케이스에서 10초 내에 끝나는지를 검사한다.

테스트가 실패한다면
단일 스레드 환경에서 속도를 끌어올릴 방법은 거의 없다.
다중 스레드라고 해도 어플리케이션이 어디서 시간을 보내는지 알아야 한다.

- I/O - 소켓 사용, 데이터베이스 연결, 가상 메모리 스와핑 기다리기 등
- 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등에 시간을 보낸다.

I/O 연산에 시간을 보낸다면
동시성이 성능을 높여주기도 한다. 시스템 한쪽이 I/O를 기다리는 동안에 다른 쪽이 뭔가를 처리해 노는 CPU를 효과적으로 활용할 수 있다.

프로세서 연산에 시간을 보낸다면
새로운 하드웨어를 추가해 성능을 높여 테스트를 통과하는 방식이 적합하다.

#### 스레드 추가하기

서버가 I/O 연산에 시간을 보낸다면, 스레드를 추가한다.

#### 서버 살펴보기

스레드 추가로 1초만에 성능 테스트를 완료하지만,
부실하기 때문에 새로운 문제를 일으킨다.

새로 고친 서버가 만드는 스레드 수를 생각해 보면 JVM이 허용하는 수까지 가능하다.
하지만 공용 네트워크에 연결된 수많은 사용자를 지원하는 시스템이면 동작을 멈출지도 모른다.

서버는 소켓 연결 관리, 클라이언트 처리, 스레드 정책, 서버 종료 정책 등의 책임을 지기 떄문에 추상화 수준도 다양하다.

현재 서버는 단일 책임 원칙SRP을 위반하므로, 잘 통제된 몇 곳으로 스레드 관리를 모아야 한다.

서버가 가져야 하는 책임 별로 클래스를 만들어 관리한다면
스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다.

#### 결론

단일스레드 시스템을 다중 스레드 시스템으로 변환해 시스템 성능을 높이는 방법과 테스트 프레임워크에서 시스템 성능을 검증하는 방법 소개
동시성과 관련한 코드를 몇몇 클래스로 집중해 단일 책임 원칙 지키기

### 가능한 실행 경로

``` java
public class IdGenerator {
  int lastIdUsed;

  public int incrementValue() {
     return ++lastIdUsed;
  }
}
```

스레드 하나가 IdGenerator 인스턴스 하나를 사용한다고 가정한다면
가능한 실행 경로는 단 하나이고 가능한 결과도 단 하나이다.

- 반환값은 lastIdUsed 값과 동일하다. 두 값 모두 메서드를 호출하기 전보다 1이 크다.

만약 IdGenerator 인스턴스는 그대로고 스레드가 두 개 라면 가능한 실행 경로는 더 생각해 봐야 한다.
lastIdUsed 초기값으로 93을 가정한다면

- 스레드 1이 94를 얻고, 스레드2가 95를 얻고 lastIdUsed가 95가 된다.
- 스레드 1이 95를 얻고, 스레드2가 94를 얻고 lastIdUsed가 95가 된다.
- 스레드 1이 94를 얻고, 스레드2가 94를 얻고 lastIdUsed가 94가 된다.

마지막 결과도 가능하므로 JVM 동작 방식을 알야 한다.

#### 경로 수

return ++lastIdUsed 자바 코드는 바이트 코드 명령 8개에 해당한다.
두 스레드에서 명령 8개를 뒤섞어 실행할 가능성이 충분하다.
루프나 분기가 없는 명령 N개를 스레드 T개가 차례로 실행한다면 가능한 경로 수는 다음과 같다.

(NT)! / Pow(N!, T)

#### 가능한 순열 수 계산하기

자바 코드 한 줄은 N=8이고 T=2이다. 계산하면 12,870개다.

만약 lastIdUsed가 long이라면 읽기/쓰기 명령은 한 단계가 아니라 두 단계로 실행된다.
그러면 가능한 경로 수는 2,704,156개로 늘어난다.

``` java
public synchronized void incrementValue() {
  ++lastIdUsed;
}
```

가능한 경로 수는 2개로 줄어든다.
스레드가 N개 라면 가능한 경로 수는 N! 이다.

#### 심층 분석

원자적 연산atomic operation은 중단이 불가능한 연산을 의미한다.
int를 long으로 바꾸면 64비트 값을 할당하는 연산은 32비트 값을 할당하는 연산 두 개로 나눠진다.
그래서 ++ 연산은 원자적 연산이 아니다.

#### 결론

여러 스레드가 서로를 훼방 놓는 시나리오가 어느 정도 머릿속에 그려지는 지식이면 충분하다.
하지만 어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.
++ 연산은 분명히 원자적 연산이 아니다.
그러므로 다음을 알고 있어야 한다.

- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법

### 라이브러리를 이해하라

#### Executor 프레임워크

자바5에서 처음 소개한 Executor 프레임워크는 스레드 풀링으로 정교한 실행을 지원한다.
스레드를 사용하지만 스레드풀을 사용하지 않는다면 Executor를 고려한다.
코드가 깔끔해지고, 이해하기 쉬워지고, 크기가 작어진다.

Executor 프레임워크는 스레드 풀을 관리하고, 풀 크기를 자동으로 조정하며, 필요하다면 스레드를 재사용한다.
Future를 지원하며 Runnable 인터페이스를 구현한 클래스, Callable 인터페이스르 구현한 클래스도 지원한다.

#### 스레드를 차단하지 않는non blocking 방법

최신 프로세서는 차단하지 않고도 안정적으로 값을 갱신한다.
AtomicBoolean, AtomicInteger, AtomicReference를 포함한 여러 클래스가 있다.

기본 타입이 아닌 객체를 사용하고, ++ 연산자가 아닌 incrementAndGet() 메서드를 사용해서
스레드 환경에서 차단하지 않고 빠르게 실행한다.

synchronized 키워드는 언제나 lock을 건다. 락의 성능이 좋아지기는 했지만 락을 거는 대가는 여전히 비싸다.

스레드를 차단하지 않는 버전은 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발한다.
스레드가 경쟁하는 상황이라도 락을 거는 쪽 보다 문제를 감지하는 쪽이 거의 항상 더 효율적이다.

#### 다중 스레드 환경에서 안전하지 않은 클래스

몇 가지 예는 다음과 같다.

- SimpleDateFormat
- 데이터베이스 연결
- java.util 컨테이너 클래스
- 서블릿

몇몇 집합collection 클래스는 스레드에 안전한 메서드를 제공한다.
스레드에 안전한 ConcurrentHashmap을 사용한다.

java.util.concurrent 패키지가 제공하는 집합 클래스는 putIfAbsent() 등과 같이 스레드에 안전한 메서드를 제공한다.

### 메서드 사이에 존재하는 의존성을 조심하라

``` java
public lass IntegerIterator implements Iterator<Integer> {
    private Integer nextValue = 0;

    public synchronized boolean hasNext() {
        return nextVAlue < 100000;
    }
    public synchronized Integer next() {
        if (nextValue == 100000)
            throw new IteratorPastEndException();
        return nextValue++;
    }
    public synchronized Integer getNextValue() {
        return nextValue;
    }
}
```

스레드 두 개가 IntegerIterator 인스턴스 하나를 공유한다면?
맨 끝에 두 스레드가 서로를 간섭해 한 스레드가 끝을 지나치는 바람에 예외가 발생할 가능성이 작게나마 존재한다. 

해결방안은

- 실패 용인
- 클라이언트를 바꿔 문제 해결
- 서버를 바꿔 문제 해결

이다.

#### 실패를 용인한다

때로는 실패해도 괜찮도록 프로그램을 조정할 수 있다. 솔직히 다소 조잡한 방법이다.

#### 클라이언트-기반 잠금

다중 스레드 환경에서도 안전한 IntegerIterator를 만들려면 (모든) 클라이언트를 다음과 같이 변경한다.

``` java
IntegerIterator iterator = new IntegerIterator();

while (true) {
  int nextValue;
  synchronized (iterator) {
    if (!iterator.hasNext())
      break;
    nextValue = iterator.next();
  }
  doSometingWith(nextValue);
}
```

비록 DRY(Don't Repeat Yourself) 원칙을 위반하지만, 다중 스레드 환경에 안전하지 못한 외부 도구를 사용하는 경우라면 필요할지도 모른다.
하지만 서버를 사용하는 모든 프로그래머가 락을 기억해 객체에 걸었다 풀어야 하므로 다소 위험한 전략이다.

#### 서버-기반 잠금

``` java
public class IntegerIteratorServerLocked {
    private Integer nextValue = 0;
    public synchronized Integer getNextOrNull() { 
        if (nextValue < 100000)
            return nextValue++;
        else
            return null;
    }
}
```

클라이언트 코드도 다음과 같이 변경한다.

``` java
while (true) {
    Integer nextValue = iterator.getNextOrNull();
    if (next == null)
        break;
    // nextValue로 뭔가를 한다.
}
```

일반적으로 서버-기반 잠금이 더 바람직한데 이유는 다음과 같다.

- 코드 중복이 줄어든다.
- 성능이 좋아진다.
- 오류가 발생할 가능성이 줄어든다.
- 스레드 정책이 하나다.
- 공유 변수 범위가 줄어든다.

서버 코드에 손대지 못한다면?

- ADAPTER 패턴을 사용해 API를 변경한 후 잠금 추가
- 아니면, 스레드 안전아며 인터페이스가 확장된 집합 클래스를 사용한다.

### 작업 처리량 높이기

URL 목록을 받아 네트워크에 연결한 다음 각 페이지를 읽어오는 코드 예제

#### 작업 처리량 계산 - 단일 스레드 환경

편의상 다음을 가정했을 때 계산

- 페이지를 읽어오는 평균 I/O 시간: 1초
- 페이지를 분석하는 평균 처리 시간: 0.5초
- 처리는 CPU 100% 사용, I/O는 CPU 0% 사용

스레드 하나가 N 페이지를 처리한다면 총 실행 시간은 1.5초 * N이다.

#### 작업 처리량 계산 - 다중 스레드 환경

순서와 무관하게 페이지를 읽어와 독립적으로 처리해도 괜찮다면 다중 스레드가 처리율을 높여줄지 모른다.
스레드별로 페이지 분석과 I/O를 사용하는 페이지 읽기를 겹쳐 실행할 수 있다.
1초에 두 페이지를 처리할 수 있으므로 단일 스레드 환경에 비교에 처리율은 세 배다.

### 데드락

데드락을 근본적으로 해결하려면 원인을 이해해야 한다.

상호 배제Mutual exclusion
잠근 & 대기Lock & Wait
선점 불가No Preemption
순환 대기Circular Wait

위 네 가지 조건을 모두 만족하면 데드락이 발생한다.

#### 상호 배제

여러 스레드가 한 자원을 공유하는데, 여러 스레드가 동시에 사용하지 못하며 개수가 제한적이라면 상호 배제Mutual Exclusion이다.

#### 잠금&대기

스레드가 자원을 점유하면 필요한 나머지 자원까지 모두 점유해 작업을 마칠 때까지 이미 점유한 자원을 내놓지 않는다.

#### 선점 불가

한 스레드가 다른 스레드로부터 자원을 빼앗지 못한다.
자원을 점유한 스레드가 스스로 내놓지 않는 이상 다른 스레드는 그 자원을 점유하지 못한다.

#### 순환 대기

죽음의 포옹deadly embrace이라고도 한다.

![image](https://user-images.githubusercontent.com/17442457/222469090-7b816caf-63d5-42cf-abe0-d14fef7c854d.png)

#### 상호 배제 조건 깨기

- 동시에 사용해도 괜찮은 자원 사용
- 스레드 수 이상으로 자원 수를 늘인다.
- 자원을 점유하기 전에 필요한 자원이 모두 있는지 확인한다.

대다수 자원은 제한적이고 동시에 사용하기 어렵다.
첫 번째 자원을 사용하고 나서야 두 번째로 필요한 자원이 밝혀지는 경우도 있다.

#### 잠금 & 대기 조건 깨기

대기하지 않으면 데드락이 발생하지 않는다.
자원을 점유하기 전에 점유를 못한다면 지금까지 점유한 자원을 모두 반납하고 처음부터 다시 시작한다.
이 방법에는 문제가 있다.

- 기아Starvation: 한 스레드가 계속해서 필요한 자원을 점유하지 못한다.
- 라이브락Livelock - 여러 스레드가 한꺼번에 잠금 단계로 진입, 계속해서 자원을 점유했다 내놨다를 반복한다.

기아는 CPU 효율을 저하시키고, 라이브락은 쓸데 없이 CPU만 많이 사용한다.

#### 선점 불가 조건 깨기

데드락을 피하는 또 다른 전략은 다른 스레드로부터 자원을 빼앗아 온다.

#### 순환 대기 조건 깨기

데드락을 방지하는 가장 흔한 전략이다.
모든 스레드가 일정 순서에 동의하고 그 순서로만 자원을 할당한다면 데드락은 불가능하다.
문제는

- 자원을 할당하는 순서와 자원을 사용하는 순서가 다를지도 모른다.
- 때로는 순서에 따라 자원을 할당하기 어렵다.

프로그램에서 스레드 관련 코드를 분리하면 조율과 실험이 가능하므로 통찰력이 높아져 최적의 전략을 찾기 쉬워진다.

### 다중 스레드 코드 테스트

동시 갱신 문제가 발생할 조건을 만들고 테스트 케이스를 만들어도 너무 드물게 발생해서 실패를 증명할 방법이 없을 때 방법

- 몬테 카를로 테스트. 조율이 가능하게 유연한 테스트를 만든다.
- 시스템을 배치할 플랫폼 전부에서 테스트를 돌린다
- 부하가 변하는 장비에서 테스트를 돌린다.

### 스레드 코드 테스트를 도와주는 도구

IBM의 ConTest라는 도구를 통해 스레드에 안전하지 않는 코드에 보조 코드를 더해 실패할 가능성을 높여주는 도구.
천만번에 한번 실패하던 코드가 서른 번에 한번 실패하는 결과를 얻을 수 있다. 

### 결론

다중 스레드 시스템을 구현하려면 알아야 할 내용이 아주 많다.
더그 리(Doug Lea)가 쓴 책 Concurrent Programming in Java: Design Principles and Patterns를 추천한다.

### 자습서: 전체 코드 예제

#### 클라이언트/서버 - 단일 스레드 버전

#### 클라이언트/서버 - 다중 스레드 버전
