## 3장 함수

읽고 이해하기 어려운 함수와
읽고 이해하기 쉬운 함수

의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

```
논의내용)
함수에 대해서 작게 만들어야 하고 이름을 정확하게 짓는 건 맞는 말이라고 생각한다.
하지만 중간에 그렇지 않은 함수가 만들어지곤 하는데
함수를 잘 만드는 방법을 몰라서가 아니라
함수를 만들어 놓고 다듬고 생각할 시간을 추가로 갖지 못해서 그런 것일수도 있다는 생각이 든다.

왜냐하면 나의 경우도 기능 구현을 위해 빠르게 짜는 경우는 
여기서 얘기한 함수 원칙에 많이 위배되지만
그 와중에도 검토하는 시간이 있으면 리팩터링을 통해 조금 더 좋게 다듬어 지기 때문이다.

원칙을 지키는 함수를 못 만드는 경우에 대해
개인의 케이스에 대해 얘기해 보면 좋을 듯
```

### 작게 만들어라!

함수를 만드는 첫째 규칙은 '작게',
둘째 규칙은 '더 작게' 이다.

되도록이면 2줄, 3줄, 4줄 정도라면 각 함수가 하는 일이 명백하다.

#### 블록과 들여쓰기

중첩구조가 생길만큼 함수가 커져서는 안 된다.
들여쓰기는 1단이나 2단을 넘어서면 안 된다.

### 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
함수가 '한 가지'만 하는지 판단하는 또 하나의 방법은 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

#### 함수 내 섹션

한 함수에서 여러 작업을 하면 섹션으로 나눠진다.
한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

### 함수당 추상화 수준은 하나로!

getHtml()은 추상화 수준이 아주 높다.
String pagePathName = PathParser.render(pagepath)는 추상화 수준이 중간이다.
append("\n")은 추상화 수준이 아주 낮다.

한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

#### 위에서 아래로 코드 읽기: 내려가기 규칙

코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
각 함수는 다음 함수를 소개한다.
각 함수는 일정한 추상화 수준을 유지한다.

### Switch 문

본질적으로 switch문은 N가지를 처리한다.
다형성polymorphism을 이용해서 각 switch 문을 저차원 클래스에 숨기고 반복하지 않는 방법을 사용한다.

switch 문을 추상 팩토리(Abstract factory)에 숨긴다.
팩토리는 switch문을 사용해 적절한 파생 클래스의 인스턴스를 생성한다.

### 서술적인 이름을 사용하라!

함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
이름이 길어도 괜찮다.
이름을 정하느라 시간을 들여도 괜찮다.

이름을 붙일 때는 일관성이 있어야 한다.
모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

### 함수 인수

이상적인 갯수는 2개 까지다.
3개는 가능한 피한다.
4개 이상은 특별한 이유가 필요하다.

출력 인수는 입력 인수보다 이해하기 어렵다.
대개 함수에서 인수로 결과를 받으리라 기대하지 않는다.

최선은 입력 인수가 없는 경우이고, 차선은 입력 인수가 1개뿐인 경우다.

테스트 관점에서 보면 인수는 더 어렵다. 
인수 한 개 까지는 괜찮다.
인수가 2개면 조금 복잡해진다.
인수가 3개를 넘어가면 인수마다 유효한 값으로 모든 조합을 구성해 테스트하기가 상당히 부담스러워진다.

#### 많이 쓰는 단항 형식

인수를 1개 넘기는 이유로
하나는 인수에 질문을 던지는 경우다. boolean fileExists("MyFile")
다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen("MyFile")

드물게 사용하지만 유용한 단항 함수 형식은 이벤트이다.
이벤트는 입력 인수만 있고 출력 인수는 없다.

단항 함수는 가급적 피한다.
void includeSetupPageInfo(StringBuffer pageText)는 피한다.
변환 함수에서 출력 인수를 사용하면 혼란을 일으킨다.

#### 플래그 인수

플래그 인수는 함수가 최소 두 가지 이상을 처리한다고 공표하는 셈이다.

render(boolean isSuite)는
renderForSuite()와 renderForSingleTest()라는 함수로 나뉘는게 좋다.

#### 이항 함수

writeField(name)은
wirteField(outputStream, name) 보다 이해하기 쉽다.

이항 함수가 적절한 경우는 직교 좌표계다.
직교 좌표계 점은 일반적으로 인수 2개를 취한다.
Point p = new Point(0, 0)

#### 삼항 함수

삼항 함수를 만들 때는 신중히 고려하라.
assertEquals(message, expected, actual)은 매번 함수를 볼 때마다 주춤할 수 밖에 없다.

#### 인수 객체

인수가 더 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어 본다.

Circle makeCircle(double x, double y, double radius);
Circle makeCircle(Point center, double radius);

변수를 묶어 넘기려면 이름이 필요하므로 결국은 개념을 표현하게 된다.

#### 인수 목록

가변 인수를 취하는 함수는 단항, 이항, 삼항으로 취급할 수 있지만 3개 이상을 넘어서면 문제가 된다.
public String format(String format, Object... args)

#### 동사와 키워드

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다.
함수와 인수가 동사/명사 쌍을 이루면 write(name)으로 표현할 수 있고 바로 이해할 수 있다.

### 부수 효과를 일으키지 마라!

부수효과는 거짓말이다.
이유는 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 것도 한다.
많은 경우 시간적인 결합temporal coupling이나 순서 종속성order dependency을 초래한다.

#### 출력 인수

일반적으로 인수를 함수 입력으로 해석한다.
public void appendFooter(StringBuffer report) 선언부를 확인하고 나서야 출력 인수라는 걸 알 수 있다.

출력 인수는 피해야 한다.
함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.

### 명령과 조회를 분리하라!

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.
객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다.

public boolean set(String attribute, String value);

set 함수는 동사로 의도하지만 return 결과를 if문에 넣고 보면 형용사로 느껴진다.

해결책은 명령과 조회를 분리해 혼란을 피한다.

public boolean attributeExists(String attribute);
public void setAttribute(String attribute, String value);

### 오류 코드보다 예외를 사용하라!

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.
성공하지 못한 코드는 여러 오류 코드를 처리해야 하는데 여러번의 if else 문이 필요할 수 있다.

예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.

#### Try/Catch 블록 뽑아내기

try/catch 블록은 정상 동작과 오류 처리 동작을 뒤섞는다.
try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.

#### 오류 처리도 한 가지 작업이다

오류를 처리하는 함수는 오류만 처리해야 마땅하다.

#### Error.java 의존성 자석

오류 코드를 반환한다는 건, 어디선가 오류 코드를 정의한다는 뜻이다.
결국 다른 코드에서 import 해서 사용해야 하므로 다시 컴파일하고 배치해야 한다.
그래서 새 오류 코드를 추가하는 대신 기존 오류 코드를 재사용한다.

### 반복하지 마라!

DRY(Don't Repeat Yourself) 원칙이다.
중복은 문제다. 코드 길이가 늘어나고 한 곳을 변경하면 중복으로 여러번 같은 부분을 변경해야 한다.
중복은 소프트웨어에서 모든 악의 근원이다.
E.F.커드는 자료에서 중복을 제거할 목적으로 관계형 데이터베이스에 정규 형식을 만들었다.
객체지향 프로그래밍은 코드를 부모 클래스로 몰아 중복을 없앤다.

하위 루틴을 발명한 이래로 소프트웨어 개발에서 지금까지 일어난 혁신은 소스 코드에서 중복을 제거하려는 지속적인 노력으로 보인다.

### 구조적 프로그래밍

데이크스트라Edsger Dijkstra의 구조적 프로그래밍의 원칙에 따르면
모든 함수와 함수 내 모든 블록에 입구entry와 출구exit가 하나만 존재해야 한다.
return도 하나여야 하고 break, continute도 자제해야 한다. goto는 절대로 안된다.

함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 클 때만 유효하다.
함수를 작게 만든다면 return, break, coutinue를 여러차례 사용해도 괜찮다.

### 함수를 어떻게 짜죠?

소프트웨어를 짜는 행위는 글짓기와 비슷하다.

먼저 생각을 기록한 후 읽기 좋게 다듬는다.
초안은 서투르고 어수선하므로 원하는 대로 읽힐 때까지
말을 다듬고 문장을 고치고 문단을 정리한다.

함수도 마찬가지다.

처음에는 길고 복잡하다.
인수 목록도 길다.
이름은 즉흥적이고 코드는 중복된다.

그 코드를 테스트하는 단위 테스트 케이스를 만들고
코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다.
메서드를 줄이고 순서를 바꾼다.
클래스를 쪼개기도 한다.
이 와중에도 테스트는 여전히 통과하도록 만든다.

### 결론

프로그래밍의 기술은 언제나 언어 설계의 기술이다.
대가master 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다.

함수를 잘 만드는 기교는 과정이고
진짜 목표는 시스템이라는 이야기를 풀어가는데 있다는 사실을 명심해야 한다.
함수가 분명하고 정확한 언어로 깔끔하게 같이 맞아 떨어져야 이야기를 풀어가기가 쉬워진다.