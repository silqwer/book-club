# Topic 37 파충류의 뇌에 귀 기울이기

말로 표현할 수 없다는 것, 생각이 아니라 느낌이라는 점이다.

해결책은 일단 본능이 반응하고 있음을 인지하는 것이다.

## 백지의 공포

많은 사람이 일을 시작하는 첫 발짝을 미루고 싶어 한다.

1. 파충류의 뇌가 무언가 할 말이 있어서다.
   1. 어떤 작업을 앞두고 마음속에 의심이 계속 남아 있거나 왠지 꺼림칙하다면, 여러분의 경험이 여러분에게 말을 거는 중일지도 모른다. 그 느낌을 따라라.
2. 그저 실수할까 두려운 것일 수 있다.

## 자신과 싸우기

여러분의 코드가 무언가 말하려는 것이다. 지금 하는 작업이 필요 이상으로 힘들다고 말이다. 어쩌면 구조나 설계가 틀렸을 수도 있고, 엉뚱한 문제를 붙들고 있을 수도 있다.

## 파충류와 이야기하는 법

`Tip 61` 여러분 내면의 파충류에게 귀 기울여라.

일단 하고 있는 일을 멈춰라. 여러분의 뇌가 정리를 좀 할 수 있도록 약간의 시간과 공간을 확보하라. 코드에 대해 생각하지 말고 키보드에서 떨어져서 잠깐 머리를 비운 채로 할 수 있는 일을 하라. 산책을 하고 점심을 먹고 다른 사람과 수다를 떨어라. 아예 하룻밤 자면서 생각해 봐도 된다. 생각이 저절로 여러분의 뇌 층층이 스며들도록 놔둬라. 억지로 쑤셔 넣을 수는 없다. 언젠가는 다시 생각이 의식의 영역으로 올라와서 `아하!`하는 순간이 찾아올 것이다.

이 방법이 잘 안되면 문제를 표면으로 끄집어내라. 작성하는 코드에 대한 그림을 그려 보라. 동료에게 설명해 보라. 고무 오리도 괜찮다.

다른 사람에게 문제를 설명하다가 갑자기 대화가 중단된 적은 그 수를 헤아릴 수 없을 만큼 많다. 갑자기 `아 , 맞다!` 라고 외치고선 문제를 고치러 달려가기 일쑤다.

여러분의 뇌에게 여러분이 하려는 일은 별문제가 없다고 알려줘야 한다. 바로 프로토타이핑을 하면 된다.

## 놀이 시간이다!

프로젝트에서 시도해 보고 싶은 특정한 측면을 찾아보라. 프로토타이핑으로 만들어라.

꺼림칙했던 느낌이 코딩 도중에 갑자기 명확한 문제로 구체화되면 즉각 해결하라.

실험을 끝마쳤는데도 여전히 불안한 마음이 들면 다시 처음부터 시작하라. 첫 단계는 산책과 수다, 그리고 휴식이다.

## `여러분`의 코드뿐이 아니다.

다른 사람의 코드를 기계적으로 읽으면서 중요해 보이는 대목은 메모해 가며 묵묵히 시간을 투자할 수도 있다.

처리 방식이 이상해 보이는 부분이 눈에 띄면 적어 놓아라. 계속 작업하면서 패턴을 찾아보라. 만약 그런 식으로 코드를 작성해야만 했던 원인을 찾아낼 수 있다면 코드를 이해하는 일이 훨씬 더 쉬워질지도 모른다.

## 코드뿐이 아니다.

직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다. 가끔은 설계가 왠지 이상하게 느껴질 수 있고 어떤 요구 사항이 마음을 불편하게 할 수도 있다. 하던 일을 멈추고 그 느낌을 분석하라.

여러분의 목소리에 귀를 기울여 주는 환경에 있다면 적극적으로 표현하라. 탐험하라. 어두운 출입구에 무언가가 숨어있을 것이다.

# Topic 38 우연에 맡기는 프로그래밍

개발자인 우리들 역시 지뢰밭에서 일한다. 하루에도 수백 개가 넘는 함정이 우리가 빠지기를 기다리고 있다.

우리는 우연에 맡기는 프로그래밍, 곧 행운과 우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다. 대신 `의도적으로 프로그래밍`해야 한다.

## 우연에 맡기는 프로그래밍 하기

몇 시간 동안 고치려고 노력했지만 프레드는 그래도 원인을 모른다. 왜 코드가 망가졌는지 프레드가 모르는 까닭은 애초에 코드가 왜 돌아가는지도 몰랐기 때문이다.

### 구현에서 생기는 우연

이제 돌아는 가니까, 그대로 놔두는 편이 더 나을 거야 …

이런 함정에 빠지기 쉽다. 잘 작동하는 데 괜히 건드려서 일을 만들 필요가 있을까? 우리가 보기에는 그래야 할 이유가 몇 가지 있다.

- 정말로 제대로 돌아가는 게 아닐지도 모른다.
- 의존하는 조건이 단지 우연인 경우도 있다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리즈에서 변경될 수 있다.
- 불필요한 추가 호출은 코드를 더 느리게 만든다.
- 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다.

다른 루틴을 호출할 때도 문서화된 동작에만 의존하라. 어떤 이유로든 그럴 수 없다면 추측을 문서로 상세히 남겨라.

### 비슷하다고 괜찮을 리는 없다.

결국 제대로 맞는 값이 없었고, 프로젝트는 폐기되었다.

### 유령 패턴

가정하지 말라. 증명하라.

### 상황에서 생기는 우연

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.

`Tip 62` 우연에 맡기는 프로그래밍을 하지 말라.

### 암묵적인 가정

가정하지 말라. 증명하라.

확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.

## 의도적으로 프로그래밍하기

- 언제나 지금 무엇을 하고 있는지 알아야 한다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있는가?
- 자신도 잘 모르는 코드를 만들지 말라.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라. 무언가를 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라.
- 가정을 기록으로 남겨라
- 코드뿐 아니라 세운 가정도 테스트해 보아야 한다. 어떤 일이든 추측만 하지 말고 실제로 시험해 보라.
- 노력을 기울일 대상의 우선순위를 정하라. 중요한 것에 먼저 시간을 투자하라.
- 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라.

# Topic 39 알고리즘의 속도

실용주의 프로그래머가 거의 날마다 하는 또 다른 종류의 추정은 바로 알고리즘이 사용하는 자원, 곧 시간, 프로세서, 메모리 등을 추정하는 것이다.

대문자 O표기법을 이용하면 된다.

## 알고리즘을 추정한다는 말의 의미

입력 크기가 클수록 알고리즘의 수행 시간이 길어지거나 사용하는 메모리 양이 늘어난다.

중요한 알고리즘은 대부분 선형적이지 않다.

## 대문자 O 표기법

O() 표기법은 우리가 측정하는 값-시간, 메모리 등 -의 상한을 기술하는 표기법이다.

그저 입력의 크기가 바뀜에 따라 값이 어떻게 바뀔지를 알려줄 뿐이다.

## 상식으로 추정하기

### 단순 반복문

만약 단순 반복문 하나가 1부터 n까지 돌아간다면 이 알고리즘은 O(n)일 가능성이 크다

### 중첩 반복문

반복문 안에 또 반복문이 들어있다면 알고리즘은 O(m x n)이 되며, 여기서 m과 n은 두 반복문의 반복 횟수다.

### 반씩 자르기

반복문을 돌 때마다 작업 대상의 수를 반으로 줄여 나가는 알고리즘이라면 고그적 알고리즘, 즉 O(lgn)이 될 가능성이 크다.

### 분할 정복

입력 데이터를 둘로 나눠서 각각 독립적으로 작업한 다음, 결과를 합치는 알고리즘은 O(nlgn)일 수 있다. 예: 퀵 정렬

### 조합적

알고리즘이 항목의 순열을 다루기 시작하면 대부분의 경우 수행 시간은 걷잡을 수 없이 늘어난다.

## 실전에서의 알고리즘 속도

단순 반복문을 작성할 때 그것이 O(n) 알고리즘이라는 사실을 안다. 입력값으로 얼마나 큰 숫자가 올 수 있는지 스스로에게 물어봐야 한다.

숫자가 외부요인에 따라 달라진다면 잠시 작업을 멈추고 커다란 수가 들어왔을 경우 수행 시간이나 메모리 소모에 어떤 영향을 미칠지 생각해 보는 것이 좋다.

`Tip 63` 사용하는 알고리즘의 차수를 추정하라.

코드의 실행 시간이 얼마나 될지 또는 메모리를 얼마나 사용할지 확실하지 않다면 직접 실행해 보라.

`Tip 64` 여러분의 추정을 테스트하라.

정확하게 시간을 재는 일이 어렵다면 코드 프로파일러를 사용하여 알고리즘이 돌아갈 때 각 단계의 횟수를 센 다음 입력값 크기별 실행 획수를 그래프로 그려보라.

## 최고라고 언제나 최고는 아니다

적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있다.

성급한 최적화를 조심하라. 언제나 어떤 알고리즘을 개선하느라 여러분의 귀중한 시간을 투자하기 전에 그 알고리즘이 정말로 병목인지 먼저 확인하는 것이 좋다.

# Topic 40 리팩터링

코드는 정적인 존재가 아니다. 코드는 발전해야 한다.

소프트웨어 개발은 건축보다 정원 가꾸기에 더 가깝다. 딱딱하기보다는 유기적인 활동이다.

→ 예전에는 건축이라고 생각했다.

사업 부서 사람들은 건물 건축이라는 메타포를 더 편안하게 여긴다. 정원일보다 더 과학적이고, 반복 가능하며, 관리를 위한 엄격한 위계질서도 갖추고 있는 등의 이유 때문이다.

→ SI 환경에서 이럴 뜻

코드 고쳐쓰기, 다시 작업하기, 다시 아키텍처 만들기는 모두 아울러서 재구성이라고 부른다. 그런데 그런 활동 중 일부를 따로 떼어 리팩터링이라는 이름으로 실천하기도 한다.

마틴 파울러의 리팩터링 핵심

1. 이 활동은 체계적이다. 아무렇게나 하는 것이 아니다.
2. 밖으로 드러나는 동작은 바뀌지 않는다. 기능을 추가하는 작업이 아니다.

무질서하게 대규모로 코드를 다시 쓰는 것이 아니라, 정확한 목적을 가지고 정밀하게 접근하는 활동이다. 그래서 코드를 바꾸기 쉽게 유지하는 것이다. → 하지만 리팩터링을 하다가 처음의 목적은 잃어버리고 딴 길로 들어서는 경우가 종종 있다.

밖으로 드러나는 동작이 바뀌지 않는다는 것을 보장하려면 코드의 동작을 검증하는 좋은 자동화된 단위 테스트가 필요하다.

## 리팩터링은 언제 하는가?

우리가 무언가를 알게 되었을 때 한다. 작년이나 어제, 심지어 10분 전과 비교해서 더 많이 알게 되었다면 리팩터링을 한다. → 깃헙 이슈를 남겨서 메모를 한다.

무엇이든 잘못되었다는 생각이 들 때가 있을 것이다. 주저하지 말고 변경하라. 언제나 바로 지금이 최적기다. 코드를 리팩터링할 이유는 아주 많다.

- 중복
  - DRY 원칙 위반을 발견
- 직교적이지 않은 설계
  - 더 직교적으로 바꿀 수 있는 무언가를 발견
- 더 이상 유효하지 않은 지식
  - 요구사항 변경
- 사용 사례
  - 진짜 사람들이 실제 상황에서 사용하며 필요하다고 느끼는 기능
- 성능
  - 성능 개선
- 태스트 통과

코드를 리팩터링하는 것 - 기능을 이리저리 옮기고 이전에 내린 결정을 바꾸는 것 -은 사실 고통 관리를 실천하는 것이다.

### 현실 세계의 복잡한 문제들

일정의 압박은 리팩터링을 하지 않는 단골 핑계다. → 정말 그렇다. 일정이 부족하다!

다른 사람에게 이 점을 설명할 때는 병에 비유하면 좋다. 리팩터링이 필요한 코드를 일종의 종양이라고 생각하자.

`Tip 65` 일찍 리팩터링하고, 자주 리팩터링하라.

일정에 리팩터링할 시간을 확실히 포함시켜 두도록 하라. → 리팩터링, 테스트

## 리팩터링은 어떻게 하는가?

리팩터링의 본질은 재설계다.

1. 리팩터링과 기능 추가를 동시에 하지 말라.
2. 리팩터링을 시작하기 전 든든한 테스트가 있는지 먼저 확인하라.
3. 단계를 작게 나누어서 신중하게 작업하라.

# Topic 41 테스트로 코딩하기

`Tip 66` 테스트는 버그를 찾기 위한 것이 아니다.

## 테스트에 대해 생각하기

## 테스트가 코딩을 주도한다

`Tip 67` 테스트가 코드의 첫 번째 사용자다.

테스트가 주는 가장 큰 이득일지 모른다. 테스트는 우리의 코딩을 인도하는 필수 피드백이다.

다른 코드와 긴밀하게 결합된 함수나 메서드는 테스트하기 힘들다. 즉 무언가를 테스트하기 좋게 만들려면 결합도도 낮아진다.

### 테스트 주도 개발

TDD의 기본 주기

1. 추가하고 싶은 작은 기능을 하나 결정한다.
2. 그 기능일 구현되었을 때 통과하게 될 테스트를 하나 작성한다.
3. 테스트를 실행한다. 테스트를 통과하고 방금 추가한 테스트 딱 하나만 실패해야 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성한다. 그리고 이제는 모든 테스트가 통과하는지 확인한다.
5. 코드를 리팩터링한다. 방금 작성한 테스트나 함수를 개선할 수 있는 부분이 없는지 살펴본다. 개선한 후에도 테스트가 계속 통과하는지 확인한다.

TDD 발상의 핵심은 이 반복 주기가 기껏해야 몇 분 정도로 매우 짧아야 한다는 것이다. 따라서 끊임없이 테스트 작성과 테스트를 통과하게 만들기를 반복하게 된다.

TDD의 노예 징후

- 늘 테스트 커버리지 100%를 달성하기 위해 과도하게 많은 시간을 투자
- 많은 수의 중복 테스트 생성
- 밑에서부터 시작해서 위로 올라가는 방식으로 설계

## TDD: 목표가 어디인지 알아야 한다.

`코끼리를 먹는 방법은?` 이라는 해묵은 농담이 있다. 답은 `한 번에 한입씩`이고 이는 TDD의 장점으로 흔히 언급되곤 한다. 전체 문제를 완전히 파악하기 힘들 때 한 번에 테스트 하나씩 작은 단계들을 밟은 것이다.

`Tip 68` 상향식이나 하향식이 아니라 끝에서 끝까지 만들어라

명백히 테스트는 개발을 이끌어 나가는 데 도움이 된다. 하지만 나아갈 때마다 목적지를 떠올리지 않으면 계속 같은 자리만 빙빙 돌게 될 수 있다.

## 다시 코드로

소프트웨어를 만들 때 맨 처음부터 테스트가 가능하도록 만들고 코드들을 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야만 한다.

## 단위 테스트

소프트웨어 단위 테스트란 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다.

## 계약을 지키는지 테스트하기

우리는 단위 테스트를 계약을 잘 지키는지 보는 테스트라고 여긴다.

하나는 코드가 계약을 지키는지 여부고, 다른 하나는 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지 여부다.

어떤 모듈이 있을 때 그 모듈의 하위 컴포넌트들을 먼저 테스트하는 방식이다. 하위 컴포넌트를 모두 검증한 후에야 해당 모듈을 테스트할 수 있다. 이 기법은 디버깅에 들어가는 노력을 줄여 주는 멋진 방법이다.

`Tip 69` 테스트할 수 있도록 설계하라.

## 임시 테스트

`임시 테스트`는 우리가 직접 코드를 이리저리 질러보는 것이다.

만든 테스트를 그냥 버리지 말고 기존의 단위 테스트 군단에 합류시켜라.

## 테스트 접점 만들기

로그 파일에 쌓이는 추적 메시지가 이런 메커니즘 가운데 하나다. 로그 메시지는 반드시 규칙적이고 일관된 형식이어야 한다.

## 테스트 문화

작성하는 모든 소프트웨어는 언젠가는 테스트된다. 여러분이나 여러분의 팀이 테스트하지 않으면 결과적으로 사용자들이 테스트하게 된다.

`테스트 먼저`가 대부분의 상황에서 최상의 선택일 것이다. 테스트를 할 수밖에 없기 때문이다. 테스트 주도 설계도 여기에 포함된다.

`코드와 테스트를 함께`가 대안이 될 수 있다. 코드를 조금 작성하고, 이리저리 만지작거리다가 테스트를 작성하라. 그리고 다시 코드로 넘어간다.

`Tip 70` 여러분의 소프트웨어를 테스트하라. 그러지 않으면 사용자가 테스트하게 된다.

# Topic 42 속성 기반 테스트

## 계약, 불변식, 속성

`계약` 선행 조건에 맞추어 입력을 넣으면 코드가 생산하는 출력이 주어진 후행 조건에 맞음을 보장 해준다.

`불변식` 함수 실행 전후로 계속 어떤 부분의 상태에 대하여 참이 되는 조건을 말한다.

`속성` 계약과 불변식을 뭉뚱그려서 속성이라고 부른다.

`Tip 71` 속성 기반 테스트로 가정을 검증하라.

## 테스트 데이터 생성

## 잘못된 가정 찾기

## 속성 기반 테스트는 우리를 자주 놀래킨다

속성 기반 테스트가 강력한 까닭은 그저 입력을 생성하는 규칙과 출력을 검증하는 단정문만 설정한 채 제멋대로 작동하도록 놔두기 때문이다.

속성 기반 테스트가 실패했다면 테스트 함수가 어떤 매개 변수를 사용했는지 알아낸 다음 그 값을 이용하여 별도의 단위 테스트를 정식으로 추가하는 것이 좋다. 이대 단위 테스트는 2가지 역할을 한다.

1. 속성 기반 테스트의 여러 가지 다른 수행 결과와 상관없이 문제가 발생하는 상황에 집중할 수 있게 해준다.
2. 회귀 테스트 역할을 한다.

## 속성 기반 테스트는 설계에도 도움을 준다

속성 기반 테스트는 여러분이 코드를 불변식과 계약이라는 관점으로 바라보게 한다. 무엇이 변하지 않아야 하고, 어떤 조건을 만족해야 하는지 생각하게 된다. 경계조건은 줄어들고, 데이터의 일관성을 해치는 함수는 더 도드라진다.

# Topic 43 바깥에서는 안전에 주의하라

## 나머지 90%

코드가 잘못될 수 있는 경우를 찾아보고 각 경우에 대한 단위 테스트를 추가하는 것이다.

내부에서 발생하는 오류뿐 아니라 외부에서 시스템을 망가트리려 하는 시도까지 고려해야 한다.

## 기본 보안 원칙

실용주의 프로그래머는 건전할 정도로 편집증을 갖고 있다.

1. 공격 표면을 최소화하라.
2. 최소 권한 원칙
3. 안전한 기본값
4. 민감 정보를 암호화하라.
5. 보안 업데이트를 적용하라.

### 공격 표면을 최소화하라

시스템의 공격표면 영역은 공격자가 데이터를 입력하거나, 데이터를 추출하거나 서비스를 실행시킬 수 있는 모든 접근 지점을 합한 것이다.

- 코드의 복잡성은 공격 매개체를 유발한다.
  - 단순하고 작은 코드가 더 낫다
- 입력 데이터는 공격 매개체다.
  - 외부의 데이터를 절대 신뢰하지 말라.
- 인증이 없는 서비스는 공격 매개체다.
- 인증을 요구하는 서비스도 공격 매체다.
  - 인증받은 사용자의 수를 언제나 최소로 유지하라.
- 출력 데이터는 공격 매개체다
  - 정보를 누설하지 말라.
- 디버깅 정보는 공격 매개체다

`Tip 72` 단순함을 유지하고 공격 표면을 최소화하라.

### 최소 권한 원칙

최소한의 권한만을 꼭 필요한 시간만큼만 제일 짧게 부여하라는 게 또 다른 핵심 원칙이다.

권한이야말로 `적을수록 낫다`

### 안전한 기본값

애플리케이션 혹은 웹 사이트 사용자의 기본 설정은 가장 안전한 값이어야 한다.

### 민감 정보를 암호화하라

개인 식별 정보나 금융 데이터, 비밀번호, 다른 인증 정보를 일반 텍스트로 남기지 말라.

### 보안 업데이트를 적용하라

`Tip 73` 보안 패치를 신속하게 적용하라.

## 상식 대 암호

다른 곳에서도 말했지만, 신뢰할 수 있는 것에만 의지를 하라. 많이 검토하고, 철저하게 검사하고, 잘 유지보수 되며 자주 업데이트되는 라이브러리와 프레임워크를 사용하라. 가급적 오픈 소스가 좋다.

# Topic 44 이름 짓기

우리는 코드에서 하는 역할에 따라 이름을 지어야 한다고 믿는다.

이름을 사용하면 코딩을 할 때마다 이 사람이 무엇을 하려고 하는지, 우리에게 어떤 의미가 있는지 계속 되새기게 될 것이다.

이름을 지을 때는 표현하고 싶은 것을 더 명확하게 다듬기 위해 끊임없이 노력해야 한다. 이렇게 명확하게 다듬는 작업이 코드를 작성할 때 코드를 더 잘 이해할 수 있도록 도울 것이다.

## 문화를 존중하라

## 일관성

반드시 팀의 모든 사람이 각 단어의 뜻을 알고 일관성 있게 사용해야 한다.

한 가지 방법은 많은 의사소통을 장려하는 것이다.

## 이름 바꾸기는 더 어렵다

무의미한 이름보다 더 고약한 잘못된 이름을 사용하는 코드가 되는 것이다.

문제를 발견했으면 고쳐라. 당장 바로 그 자리에서, 의도를 제대로 표현하지 못하거나 오해를 부를 수 있거나 헷갈리는 이름을 발견했다면 고쳐야 한다.

`Tip 74` 이름을 잘 지어라. 필요하면 이름을 바꿔라.
