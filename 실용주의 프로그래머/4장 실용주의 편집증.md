# Topic 23 계약에 의한 설계

## DBC

DBC는 단순하지만, 강력한 기법으로 프로그램의 정확성을 보장하기 위해 소프트웨어 모듈의 권리와 책임을 문서화하고 합의하는 데에 초점을 맞춘다.

- 선행조건 `precondition`
  - 루틴이 호출되기 위해 참이어야 하는 것, 즉, 루틴의 요구사항
- 후행 조건 `postcondition`
  - 루틴이 자지가 할 것이라고 보장하는 것. 즉, 루틴이 완료되었을 때 세상의 상태
- 클래스 불변식 `class invariant`
  - 호출자의 입장에서 볼 때는 이 조건이 언제나 참인 것을 클래스가 보장한다.

무슨 일이 벌어지든지 확실한 점은 계약에 부응하지 못하는 것이 버그라는 것이다.

`Tip 37` 계약으로 설계하라.

`부끄럼쟁이` 코드를 작성하고 `게으름뱅이` 코드를 강조한다.

시작하기 전에 자신이 수용할 것은 엄격하게 확인하고, 내어 줄 것에 대해서는 최소한도를 약속하라.

## DBC 구현

코드를 작성하기 전에 유효한 입력 범위가 무엇인지, 경계 조건이 무엇인지, 루틴이 뭘 전달한다고 약속하는지, 혹은 더 중요하게 무엇을 약속하지 않는지 등을 나열하는 것만으로도 더 나은 소프트웨어를 작성하는 데 엄청난 도움이 된다.

DBC는 결국 설계 기법이다. 자동 검사가 없더라도 계약을 코드에 주석이나 단위 테스트로 넣어둘 수 있고, 여전히 실질적인 소득이 있다.

### 단정문

근본적인 문제는 계약이 자동으로 집행되지 않는다는 것이다.

## DBC와 일찍 멈추기

DBC는 우리의 `일찍 작동을 멈춰라.` 라는 개념과 잘 어올린다.

선행 조건과 후행 조건, 불변식을 검증하면 더 일찍 멈추고, 문제에 대한 보다 정확한 정보를 알려줄 수 있을 것이다.

문제를 찾고 원인을 밝히기 위해서는 사고가 난 지점에서 일찍 멈추는 것이 유리하다.

## 의미론적 불변식

`의미론적 불변식`을 사용하면 일종의 `철학적 계약`인 절대 어겨서는 안 되는 요구 사항을 표현할 수 있다.

불변식의 자격이 있는 요구 사항을 찾았다면 여러분이 작성하는 모든 문서에 잘 드러나도록 만들어라.

여러분이 찾은 의미론적 불변식을 잘 드러내야 한다.

명확하고 모호한 점이 없게 서술하도록 노력하라.

## 동적 계약과 에이전트

에이전트 기술에 의존하는 어떤 시스템이건 계약의 합의가 결정적으로 중요하다는 점은 분명하다.

수동으로 계약을 만들 수 없다면 자동화하는 것은 꿈도 꿀 수 없다.

소프트웨어를 설계하게 되면 계약 역시 설계하도록 하라.

# Topic 24 죽은 프로그램은 거짓말을 하지 않는다

`그런 일은 절대 일어날 리 없어.` 라고 사고에 빠지기 쉽다.

우리는 지금 방어적으로 코딩하고 있다.

실용주의 프로그래머는 만약 오류가 발생했다면 정말로 뭔가 나쁜 일이 생긴 것이라고 자신에게 이야기한다.

일단 그놈의 오류 메시지 좀 읽어라.

## 잡은 후 그냥 놓아주는 것은 물고기뿐

`Tip 38` 일찍 작동을 멈춰라.

## 망치지 말고 멈춰라

가능한 한 빨리 문제를 발견하면 좀 더 일찍 시스템을 멈출 수 있으니 더 낫다.

`방어적 프로그램은 시간 낭비다. 그냥 멈추는 게 낫다!`

기본 원칙은 똑같다. 방금 있을 수 없는 일이 발생했다는 것은 코드가 발견했다면 프로그램은 더는 유효하지 않다고 할 수 있다.

일반적으로 죽은 프로그램이 끼치는 피해는 이상한 상태의 프로그램이 끼치는 피해보다 훨씬 적은 법이다.

# Topic 25 단정적 프로그래밍

요구사항, 설계, 코드, 주석 등 우리가 하는 거의 모든 것에 적용하도록 배우는 컴퓨팅의 근본 교리이자 핵심적 믿음이다.

`Tip 39` 단정문으로 불가능한 상황을 예방하라.

진짜 오류 처리를 해야 하는 곳에 단정을 대신 사용하지는 말라.

## 단정과 부작용

디버깅 행위가 디버깅하려는 시스템의 행동을 바꿔 버리는 일종의 `하이젠버그` 적인 문제다.

## 단정 기능을 켜 둬라

단정 기능의 오해

1. 테스트가 모든 버그를 발견한다는 가정이다.
2. 낙관주의자들은 여러분의 프로그램이 험한 세상에서 돌아간다는 사실을 잊는다.

# Topic 26 리소스 사용의 균형

개발자가 리소스 할당과 해제를 다루는 일관된 방침을 갖고 있지 않다.

`Tip 40` 자신이 시작한 것은 자신이 끝내라.

리소스를 할당하는 함수나 객체가 리소스를 해제하는 책임 역시 져야 한다

`자신이 시작한 것은 자신이 끝내라.` 팁이 가르쳐 주는 것은 이상적으로 말해서 리소스를 할당하는 루틴이 해제 역시 책임져야 하는 것이다.

`Tip 41` 지역적으로 행동하라.

## 중첩 할당

1. 리소스를 할당한 순서의 역순으로 해제하라.
2. 코드의 여러 곳에서 동일한 구성의 리소소들을 할당하는 경우에는 언제나 같은 순서로 할당해야 교착 가능성을 줄일 수 있다.

## 객체와 예외

객체 지향 언어로 프로그래밍을 한다면 리소스를 클래스 안에 캡슐화하는 것이 유용할 수 있다.

## 균형 잡기와 예회

## 리소스 사용의 균형을 잡을 수 없는 경우

한군데 모은 자료 구조 안의 자료를 누가 책임지는지 정해 놓아야 한다.

1. 최상위 구조가 자기 안에 들어 있는 하위 구조들을 해제할 책임을 진다.
2. 최상위 구조가 그냥 할당 해제된다.
3. 최상위 구조가 하나라도 하위 구조를 가지고 있으면 자신의 할당 해제를 거부한다.

## 균형을 점검하기

실용주의 프로그래머는 자신을 포함해서 아무도 믿지 않는다.

정말로 리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 작성하는 것을 좋아한다.

래퍼를 사용해서 상태가 올바른지 점검하라.

# Topic 27 헤드라이트를 앞서가지 말라

`Tip 42` 작은 단계들을 밟아라. 언제나.

언제나 신중하게 작은 단계들을 밟아라. 더 진행하기 전에 피드백을 확인하고 조정하라.

불확실한 미래에 대비한 설계를 하느라 진을 빼는 대신 언제나 교체 가능한 코드를 작성하여 대비하면 된다.

## 블랙 스완

`Tip 43` 예언하지 말라.
