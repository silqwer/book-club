# 3.1 이터레이션

이터레이션 패턴은 수십 년 동안 사용되어 온 디자인 패턴이다. 이 패턴을 사용하면 데이터를 덩어리 단위로 표준화된 방법을 사용해 처리할 수 있다.

질의 결과가 백 줄, 천 줄 혹은 그 이상이라면 루프 같은 반복적인 방식을 사용해 데이터를 처리해야 하는데 이때 바로 이터레이터 패턴을 사용한다.

이터레이터는 next()레코드나 줄과 같은 데이터 조각이 차례대로 반환된다. 특별한 값을 사용하거나 예외를 발생시켜 반복 작업이 종료되었다는 신호를 준다.

이터레이터 패턴의 핵심은 반복 작업으로 데이터를 처리할 때 표준화된 방법을 제공한다는 점이다.

## 3.1.1 이터레이터 소피하기

…은 대칭 형태인 전개 구문과 나머지 매개변수를 이용해 사용합니다. 이터레이터를 펼치려면 펼칠 무언가가 있어야 합니다. js에서는 배열이나 함수 호출 시 넘기는 인수를 다룰 때 이런 시나리오가 가능하다.

## 3.1.2 이터러블

이터레이터 소비 프로토콜은 순회 가능한 값인 이터러블을 소비하는 기술적인 방법이라고 정의할 수 있다. ES6에서는 문자열, 배열, 맵, 셋 같이 기본이 되는 자료구조나 컬렉션을 이터러블로 정의한다.

이터레이터를 소비해 배열을 얕게 복사할 수 있다.

```jsx
var arrCopy = [...arr];
```

맵은 기본 이터레이터를 지원한다. entries를 호출하면 맵의 값뿐만 아니라 키까지 포함한 2차원 배열인 entry 튜플을 순회할 수 있다. values()를 사용하면 값을 대상으로만 이터레이터가 작동한다.

배열의 인덱스와 값을 대상으로 순회하고 싶다면 다음과 같이 entries() 메서트를 사용할 수 있다.

# 3.2 클로저

부지불식간에 거의 모든 JS 개발자는 클로저를 이용하고 있다. 클로저는 JS를 지탱하는 근본적인 기술이다.

클로저란 함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에 계쏙 접근할 수 있는 경우를 의미한다.

### 특징

1. 클로저는 함수의 탁난 특징이다. 객체는 클로저가 되지 않지만 함수는 자연스럽게 클로저가 된다.
2. 클로저를 직접 보고 싶다면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행해야한다.

클로저는 변수 msg를 스냅숏한 값(복사해서 별도로 만든 값)을 사용하지 않는다. 대신 변수 자체와 직접적인 관계를 맺어 변수가 업데이트되는 것을 관찰하고 최신값을 가져와서 사용한다.

클로저는 스냅숏한 값을 사용하지 않고 변수 그 자체와 직접적인 관계를 맺는다.

# 3.3 this 키워드

함수는 정의되는 시점에 클로저를 통해서 함수를 에워싸는 스코프에 부착된다.

함수는 스코프 말고도 자신이 어디까지 접근 가능한지 결정하는 함수만의 특징을 갖는다. 이 특성을 실행 컨텍스트 개념으로 가장 잘 설명되며 함수는 this 키워드를 통해 실행 컨텍스트에 접근한다.

스코프는 정적이며 함수를 정의하는 순간, 해당 스코프에서 사용할 수 있는 한정된 변수 집합을 포함한다. 반면 함수의 실행 컨텍스트는 동적이다. 함수의 호출 방식에 따라 결정된다.

즉 this는 함수의 정의에 종속되어 결정되는 변치 않는 특성이 아니라, 함수를 호출할 때마다 결정되는 동적인 특성이다.

실행 컨텍스트는 함수가 실행되는 동안 함수에서 사용할 수 있는 프로퍼티를 가진 유형의 객체라고 생각하면 이해하기 쉽다.

this를 사용하면 동적으로 컨텍스트를 지정할 수 있으므로 특정한 작업 환경에 아주 유용하다.

# 3.4 프로토타입

프로토타입은 객체, 구체적으로 프로퍼티에 접근할 때 일어나는 동작과 관련된 특징이다.

프로토타입은 두 객체를 연결하는 연결 장치이다.

프로토타입이라는 연결 장치는 객체가 생성될 때 만들어지고, 이 장치를 통해 새롭게 생성된 객체는 기존에 존재하는 다른 객체에 연결된다.

프로토타입을 통해 연결된 일련의 객체는 프로토타입 체인이라고 부른다.

프로토타입 연결 장치가 존재하는 이유는 B에는 없는 프로퍼티나 메스드에 접근하려 할 때, 객체 A에서 위임을 받아 해당 접근을 처리할 수 있도록 하기 위해서다.

## 3.4.1 객체 연결 장치

Object.create()를 사용해 객체를 만들어 객체 프로토타입 연결 장치를 직접 정의할 수 있다.

## 3.4.2 this 다시 보기

함수 호출 시 this가 동적으로 컨텍스트를 가져오는 중요한 이유는 프로토타입 체인을 통해 위힘한 객체에 있는 메서드를 호출할 때, this가 코드 작성자의 의도대로 되게끔 하는데 있다.

# 3.5 왜? 라고 질문하기

새로운 무언가를 만났을 때 왜? 라는 질문을 던지는 게 매우 중요하다.

올바른 질문을 하는 것은 더 나은 개발자로 만드는 아주 중요한 기술이다.
