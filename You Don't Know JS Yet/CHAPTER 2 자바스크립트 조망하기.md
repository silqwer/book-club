# 2.1 파일을 프로그램입니다

JS에서는 파일이 각각이 별도의 프로그램이다.

파일 각각을 프로그램으로 봐야 하는 게 중요한 이유는 주로 오류 처리와 관련이 있다.

JS는 파일 하나에만 오류가 있어도 다음 파일이 처리되지 않을 수 있다.

각 파일이 제대로 작동하는지 확인하고, 오류가 발생하더라도 최대한 우아하게 처리하는 게 중요하다

파일을 import 문이나 <script type=module> 태그를 통해 읽는 경우, 해당 파일은 하나의 모듈로서 처리된다.

파일이든 모듈(상태와 외부에 노출할 용도로 만든 상태 조작 메서드의 모음)이든 고유한 작은 프로그램이라고 생각해야 한다.

# 2.2 값

백틱에서 값이 대체되는 방식을 보간법이라고 한다. 보간이 필요 없는 경우에는 큰 따움표나 작은 따옴표 중 하나를 일관되게 사용하는 게 좋다.

비어 있는 단일 값을 나타낼 때는 undefined를 사용하는 게 가장 안전한 최선의 방법이다.

## 2.2.1 배열과 객체

객체는 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션이다.

## 2.2.2 값의 타입

typeof 연산자를 사용해 원시 타입 값과 객체 타입 값을 구분합니다.

# 2.3 변수 선언과 사용

변수는 값을 담는 상자라고 생각하면 된다.

var로 선언한 변수는 접근 범위가 함수스코프이다.

let으로 선언한 변수는 변수 접근 범위가 블록이다.

# 2.4 함수

JS에서 함수는 할당 가능하고 어디든 전달 가능한 값이라는 특징은 매우 중요하다.

JS에서 함수는 객체의 한 종류이다.

함수형 프로그래밍 패러다임을 지원하는 언어에서는 함수를 값으로 취급하는 게 필수이다.

함수는 값이므로 함수를 객체의 프로퍼티로 할당할 수 있다.

# 2.5 비교

## 일치 비교 `===`

- NaN이나 -0과 함께 사용되면 예상과 다르게 동작한다.
  ```tsx
  NaN === Nan; // false
  0 === -0; // true
  ```

=== 연산자는 NaN이나 -0과 함께 쓰지 않는게 최선이다. NaN과 비교할 땐 거짓말을 하지 않는 Number.isNaN()을 사용하고 -0과 비교할 때는 Object.is()를 사용해라.

일치 비교는 값의 본질이나 내용을 비교한다고 볼 수 있다.

JS에서는 객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않고 독자성 일치를 비교한다.

JS에서 객체는 참조에 의해 고정되며 참조 복사본을 사용해 할당, 전달 된다. 그리고 참조를 대상으로 일치 비교가 일어난다.

## 2.5.2 강제 반환

동등 비교 `==` 는 비교 이전에 강제로 타입을 맞추는 작업을 수행한다는 점에서 === 연산자와 차이가 있다.

== 연산자는 강제 변환을 먼저 실행해 피연산자의 타입을 맞춘 이후에 === 연산자처럼 작동한다.

== 연산자는 강제 변환 동등 비교 연산자라고 저자는 생각한다.

==와 마찬가지로<,>,≤,≥는 피연산자들의 타입이 같으면 === 처럼 다르면 == 처럼 작동한다.

# 2.6 코드 구조화 패턴

## 2.6.1 클래스

클래스는 사용자가 정의한 데이터 타입으로 데이터와 이 데이터를 조작하는 동작이 들어간다.

클래스가 없다면 체계적이지 않고 가독성이 떨어지며 유지 보수하기 어려운 프로그램이 될 가능성이 높다.

## 2.6.2 모듈

모듈 패턴은 클래스와 마찬가지로 논리적 단위 기준으로 데이터와 행동을 그룹화하는 데 그 목적이 있다.

### 클래식 모듈

단순한 함수이기도 하고 함수를 호출하면 모듈 인스턴스가 생성되기 때문에 모듈 팩토리라고 설명하기도 한다.

### ES 모듈

ES모듈은 파일이라는 맥락에서 구현된다. ES 모듈 파일 하나는 모듈 하나이다.

ES 모듈을 인스턴스화하지 않아도 import 키워드를 사용해 가져오기만 한다면 단일 인스턴 처럼 사용할 수 있다.

import 키워드를 사용해 처음 모듈을 가져온 순간 인스턴스가 생기고, 동일한 모듈을 다른 곳에서 import 할 때는 이미 생성된 모듈의 참조만 가져온다.

ES 모듈은 사실상 싱글턴이라고 할 수 있다.

# 2.7 더 깊은 토끼 굴로
