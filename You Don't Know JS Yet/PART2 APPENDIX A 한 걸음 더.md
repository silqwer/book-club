# A.1 암시적 스코프

스코프는 가끔 명확하지 않은 위치에 생성된다.

- 매개 변수 스코프
- 함수용 스코프

## A.1.1 매개변수 스코프

단순하지 않은 매개변수는 작동 방식이 다르다. 기본값이 있는 매개변수, …을 사용하는 나머지 매개변수, 비구조화 매개변수가 대표적인 예이다.

단순하지 않은 매개변수 형태는 다양한 예외 케이스를 발생시킨다. 이런 예외 케이스를 효과적으로 처리하기 위해 단순하지 않은 매개변수는 자체 스코프를 형성한다.

- 지역 변수로 매개변수를 섀도잉하지 마라.
- 기본 매개변수에서는 다른 매개변수를 참조하지 마라.

## A.1.2 함수 이름 스코프

함수 표현식의 이름과 동일한 변수를 함수 본문 내부에서 let으로 선언하는 것은 피해라.

# A.2 익명 함수 vs. 기명 함수

- 이름 추론은 불완전하다.
- 렉시컬 이름을 사용하면 자기 참조가 가능하다.
- 이름은 설명을 제공하기 때문에 유용하다.
- 화살표 함수에는 렉시컬 이름이 없다.
- IIFE에도 이름이 필요하다. → 이 부분은 도움이 된다고 느꼈다.

## A.2.1 명시적 혹은 추론된 이름

목적이 있다면 그 목적에 부합하는 이름이 있다.

이름이 스택 트레이스에 추가되면 디버깅 시 유용한 정보를 얻을 수 있다. 모든 함수에 적절한 이름을 부여하면 더 쉽게 프로그램을 디버깅할 수 있다.

## A.2.2 이름이 없다면?

이름 추론에 의존하는 건 불완전하다.

## A.2.3 나는 누구일까요?

렉시컬 이름 식별자가 없으면 함수는 내부적으로 자기 자신을 참조할 방법이 없습니다. → 이름이 없으니까

자기 참조는 재귀나 이벤트를 처리하는 작업에서는 매우 중요하다. → 필요하다면 이름을 넣어 사용하자

## A.2.4 이름은 설명입니다.

함수에서 이름을 생략하면 코드를 읽는 사람이 함수의 목적을 빠르게 파악하기 어렵다.

적절한 이름을 사용하면 이 과정을 쉽고 빠르게 수행할 수 있다. → 많은 책에서 나오는 좋은 이름 짓기의 중요성!

함수의 길이나 복잡도에 상관없이 함수에는 함수의 목적을 나타내는 이름을 추가해야 한다.

좋은 이름이 떠오르지 않는다면 함수와 목적을 이해하지 못하고 있을 가능성이 있다. 함수를 제대로 설계하지 않았거나, 함수에서 하는 일이 너무 많을 수 있다. 이럴 경우에는 재작업이 필요하다. 잘 설계된 단일 목적 함수는 이름을 선정하기 쉽다.

이름을 지정하지 않으면 프로그램 가독성이 떨어지고, 디버깅하기 어렵고, 나중에 확장 및 유지 보수가 어려워진다.

## A.2.5 화살표 함수

일반 함수를 대체하는 용도로 화살표 함수를 사용하지 말아라. 더 간결할 수 있지만 간결함으로 인해 코드의 내용을 빠르게 분석하는 데 도움을 주는 시각적인 주요 구분 기호가 생략되는 대가를 치러야 한다.

## A.2.6 IIFE 변형

모든 함수는 이름이 있어야 한다. IIFE 도 여기에 포함된다.

IIFE가 사용된 목적을 알 수 있다.

# A.3 호이스팅: 함수와 변수

- 실행 가능한 코드 먼저, 함수 선언은 아래쪽에 배치 → 🤔 동의할 수 없는 의견
- 변수 선언의 의미 있는 배치

## A.3.1 함수 호이스팅

필자는 스코프의 모든 레벨에서 호이스팅을 응용한 배치(거꾸로 배치) 방식을 사용하며 추천하지만, 그 생각에 동의할 수 없다.

## A.3.2 변수 호이스팅

let과 const는 호이스팅되지만 TDZ에서는 해당 변수를 사용할 수 없다.

# A.4 var에 대한 변론

## A.4.1 var를 버리지 마세요

난 버렸다.

## A.4.2 혼란스러운 const

값 불변성과 할당 불변성은 엄연히 다르다.

## A.4.3 var와 let

필자는 const가 거의 쓸모가 없다고 말한다. → 동의 못 한다.

# A.5 TDZ

- const는 절대 바뀌지 않아야 한다.
- 중요한 것은 시간이다.
- let은 const처럼 작동하는 게 나은지 아니면 var처럼 작동하는 게 나은지 알아야 한다.

## A.5.1 모든 일이 시작된 곳, const

var처럼 const와 let도 호이스팅된다.

let과 const가 블록의 맨 위로 호이스팅되어 변수가 블록 전체에서 일관된 동작을 보일 수 있게 해야 한다.

변수가 처음 존재하는 시점과 값이 할당되는 시점 사이에 붕 뜨는 시간은 어떻게 처리해야 할까? 이 시간을 TDZ라 부른다. TDZ에 있는 변수에 접근하는 걸 허용하지 않고, 접근하려 할 때 TDZ 오류를 발생시킨다.

## A.5.2 곁다리 let

let은 const보다 var에 더 가깝다.

# A.6 동백 콜백도 여전히 클로저일까?

- 관찰 관점: 함수가 다른 스코프로 전달되거나 호출될 때에도 함수 인스턴스가 외부 변수를 기억하는 현상
- 구현 관점: 함수 인스턴스와 그 스코프 환경은 원래 위치에 보존되어 있고 함수 인스턴스에 대한 참조만 다른 스코프에 전달되고 호출되는 현상

핵심

- 무엇을(혹은 어디서) 콜백하는가?
- 동백 콜백이라는 이름이 최선인가에 대한 고찰
- IIF 함수는 움직이지 않는데, 왜 클로저가 필요한가?
- 클로저의 핵심은 시간에 따른 연기

## A.6.1 콜백이란

일반적으로 콜백은 비동기 콜백과 동기 콜백을 모두 지칭한다.

비동기 콜백에서 콜백은 현재 실행 중인 코드가 완료되거나 일시 중단된 상태에서 미래의 어느 시점에 되돌아와 다시 호출하는 함수를 의미한다.

콜백은 비동기다.

## A.6.2 동기 콜백

프로그램의 다른 부분이 호출을 대신할 수 있도록 함수(참조)를 전달하는 것은 동기 콜백이라는 용어보다 DI(의존성 주입) 또는 IoC(제어의 역전)라는 용어가 더 올린다.

DI는 필요한 기능이나 기능의 일부를 프로그램의 다른 부분으로 전달하는 것으로 요약할 수 있다.

IoC는 프로그램의 현재 영역에서 일어나는 일을 제어하는 대신 제어권을 프로그램의 다른 부분으로 넘기는 것을 의미한다.

마틴 파울러는 프레임워크와 라이브러리의 차이를 IoC로 설명한다. 라이브러리를 사용할 때는 라이브러리의 함수를 호출하지만, 프레임워크를 사용할 때는 프레임워크가 우리가 작성한 함수를 호출한다고 이야기한다.

## A.6.3 동기 클로저

클로저를 어떻게 정의하느냐에 따라 IIF가 클로저로 간주될 수 있는지가 결정된다.

## A.6.4 클로저 지연

수동으로 커링을 사용

# A.7 클래식 모듈 변형

- 모듈은 자체 API에 대한 정보를 아는 것이 좋다.
- 화려한 모듈 로더를 사용하더라도 결국 클래식 모듈일 뿐이다.
- 일부 모듈은 환경에 상관없이 동일하게 작동해야 한다.

## A.7.1 내 API는 어디에 있나요?

- publicAPI라는 이름 자체가 객체의 목적을 명확하게 해주므로 가독성을 높인다.
- 반환할 외부 공개용 API 객체를 참조하는 내부 변수 publicAPI를 따로 두면 모듈이 살아 있는 동안 API에 접근하거나 수정해야 할 때 유용하다.

## A.7.2 AMD

AMD도 클래식 모듈과 동일한 원칙(클로저 작동 방식 포함)을 기반으로 작동한다.

## A.7.3 UMD

UMD는 IIFE에 불과하다.
