# 4.1 전역 스코프를 배워야 하는 이유

브라우저에서 실행되는 애플리케이션은 주로 세 가지 방법을 사용한다.

1. ES 모듈
   1. 각 파일이 개별적으로 로딩
   2. 서로 스코프를 공유하지 않음
   3. 모듈 간 독립적 협업 구조
2. 번들러 사용
   1. 모든 코드가 하나의 파일로 합쳐짐
   2. 브라우저는 이 큰 파일만 처리
   3. 내부 조각을 이름으로 등록하거나 접근해야 함
   4. 내부 메커니즘이 필요
3. 전역 스코프 활용
   1. 모듈 방식이든 아니든, 개별 파일로 로딩하더라도 전역 스코프를 공유하면 서로 협업이 가능하다.

전역 스코프를 사용할 수 있는 케이스

- JS 내장 기능을 사용할 때
  - 원시 값: undefined, null, Infinity, NaN
  - 네이티브 객체: Date(), 0bject(), String() 등
  - 전역 함수: eval(), parseInt() 등
  - 네임스페이스: Math, Atomics, JSON
  - JS와 협력 관계인 기술: Intl, webAssembly
- 특정 호스팅 환경에서 제공하는 내장 기능을 사용할 때
  - console과 연관 메서드
  - DOM (window, document 5)
  - 타이머(setTimeout () 등)
  - 웹 API: navigator, history, 지오로케이션(geolocation), WebRTC 등

변수 전체를 전역 스코프에 선언하는 건 버그가 발생하길 기도하는 것과 같다.

# 4.2 전역 스코프의 위치

## 4.2.1 브라우저의 창, window 객체

식별자가 전역 스코프에 선언된다는 말은 전역 객체(브라우저에서 대개 window 객체)의 프로퍼티를 통해 해당 식별자에 접근한 수 있다는 말과 같다.

### 전역을 가리는 전역

전역 스코프에서는 전역 객체의 프로퍼티가 전역 변수에 의해 가려진다.

전역에 무언가를 선언할 때 실수를 막을 수 있는 좋은 방법은 전역에서는 항상 var를 쓰는 것이다.

### DOM 전역 변수

DOM 요소에 id 속성을 추가하면 전역 변수가 자동으로 생기고, 이 변수를 통해 해당 DOM 요소에 접근할 수 있다.

### window.name의 정체

window의 name 프로퍼티는 사전에 정의된 getter이자 setter이다. setter는 어떤 값을 넣는 문자열로 변환시키는 규칙이 있다.

## 4.2.2 웹 워커

**웹 워커(Web Worker)**는 JS 코드를 **메인 스레드가 아닌 별도의 스레드**에서 실행하게 해주는 기능이다.

이로 인해 **DOM 접근 불가**, **전역 스코프(window) 공유 불가**, **레이스 컨디션 회피 가능** 등의 특징이 있다.

- 별도 스레드에서 실행됨 (메인 JS 프로그램과 격리)
- DOM 접근 불가 (document, window 사용 불가)
- 전역 객체 접근 시 self 사용
- navigator 등 일부 API는 예외적으로 접근 가능

완전히 독립된 JS 실행 환경을 제공하여 메인 UI의 성능을 해치지 않고 **병렬 처리**가 가능하게 한다.

## 4.2.3 개발자 도구와 콘솔, REPL

개발자 도구(콘솔, REPL 등)는 **JS 코드를 정확히 실행**하는 것이 아니라, **개발자 경험(DX)**을 **향상시키기 위해 UX 중심으로 설계**되어 있다.

- JS 엔진의 **전역 스코프와 다르게 동작**할 수 있다
- let, const, 호이스팅 등에서 일반 JS 실행과 **차이가 발생**
- 이는 에뮬레이터적 특성 때문이며, **편의성을 우선**한 결과

즉, 개발자 도구에서 JS가 다르게 동작해도 이상한 게 아님 → **실제 환경과 완전히 동일하지 않음**

## 4.2.4 ES 모듈

ES 모듈은 파일 내 최상위 코드라도 **전역 변수로 등록되지 않으며**, **모듈 범위(module scope)** 안에서만 유효한 변수가 된다.

- studentName, hello는 전역 변수 X → 모듈 범위 변수

따라서 모듈은 **고립된 스코프**를 가지며, export/import 없이는 외부에서 접근 불가하다.

## 4.2.5 Node.js

브라우저에서 모듈이 아닌 파일을 로드할 때와 다르게 각 JS 파일이 자체 스코프를 갖도록한다.

진짜 전역 변수는 Node.js 내장 전역 프로퍼티인 global에 프로퍼티를 추가하는 방법이 유일하다.

# 4.3 globalThis

지금까지 여러 JS 호스팅 환경을 살펴봤는데, 호스팅 환경마다 차이를 보이는 특징을 정리하면 다음과 같다.

- 최상위 레벨 스코프에 var, function 또는 let, const, class를 사용해 전역 변수를 선언할 수 있는데 두 방식에는 차이가 있다.
- var 또는 function을 사용해 선언하는 경우 해당 선언은 전역 객체의 프로퍼티로 추가된다.
- 전역 스코프 객체(전역 변수를 추가하거나 검색할 때 프로퍼티로 사용)는 window, self, global로 참조한다.

ES2020에서 마침내 전역 스코프 객체 참조가 globalThis로 표준화되었다.

# 4.4 정리

모듈 단위 개발 방식이 자리 잡으면서 전역 네임스페이스에 식별자를 저장하는 방식은 많이 쓰지 않는다. 그럼에도 불구하고 전역 스코프는 모든 JS 프로그램에 존재하고 중요한 역할을 한다.
