모듈은 본질적으로 렉시컬 스코프와 클로저를 기반으로 만들어진다.

# 8.1 캡슐화와 최소 노출의 원칙(POLE)

캡슐화의 목표는 정보(데이터)와 동작(함수)을 한데 묶거나 함께 배치해 공통의 목적을 달성하는 것이다.

캡슐화는 공통의 목적을 가진 코드 일부분을 별도의 파일에 옮기는 것만으로도 실현할 수 있다.

캡슐화의 또 다른 주요 목표는 캡슐화된 데이터와 함수의 특정 측면의 가시성을 제어하는 것이다.

JS에서는 주로 렉시컬 스코프 메커니즘을 사용해 가시성 제어라는 목표를 달성한다.

캡슐화의 주요 아이디어는 비슷한 코드를 그룹화하고, 공개하고 싶지 않은 세부 사항은 접근을 선택적으로 제한하는 것이다. 비공개(`private`)로 분류되지 않은 부분은 공개(`public`)로 표시하고 프로그램 전체에서 접근할 수 있게 한다.

# 8.2 모듈이란

모듈은 관련된 데이터와 함수(문맥상 메서드라고도 함)의 모음이다. 공개적으로 접근 가능한 세부 정보를 공개 API라 부른다.

> 모듈 패턴의 주요 관심사는 느슨한 결합을 통한 모듈화나 기타 프로그램 아키텍처 기술을 통해 시스템 수준의 모듈화를 완전히 수용하는 데 있다.

## 8.2.1 네임스페이스(무상태 그룹화)

데이터 없이 관련된 함수를 그룹으로 묶는 것은 모듈에서 이야기하는 캡슐화가 아니다. 이러한 무상태 함수를 모아 놓은 것을 `네임스페이스` 라고 부른다.

## 8.2.2 데이터 구조(상태 유지 그룹화)

데이터와 상태를 가진 함수를 하나로 묶는다 하더라도 데이터의 가시성을 제한하지 않는다면 POLE 관점에서 캡슐화가 아니다. 데이터 구조의 인스턴스라는 이름을 붙이는 게 좋다.

## 8.2.3 모듈(상태를 가진 접근 제어)

모듈 패턴이 가진 정신을 실체화하려면 상태와 함수를 그룹화하는 것뿐만 아니라 가시성(공개 vs 비공개) 제어를 통한 통제도 필요합니다.

모듈 패턴에서는 모듈 내부에 변수와 함수를 정의함으로써 외부에서 해당 변수, 함수에 접근할 수 없게 한다. 공개 API 객체에 추가된 프로퍼티만 외부에서 접근할 수 있다.

### 모듈 팩토리 (다중 인스턴스)

IIFE로 정의하지 않고 일반적인 독립형 함수로 정의한 함수

### 클래식 모듈 정의

- 적어도 한 번 이상 실행되는 모듈 팩토리 함수가 외부 스코프에 존재해야 한다.
- 모듈의 내부 스코프에는 해당 모듈의 상태를 나타내는 정보가 최소한 하나 이상 있어야 하며, 이는 외부에서 접근할 수 없어야 한다.
- 모듈은 하나 이상의 함수를 공개 API로 반환해야 한다. 이 함수는 내부 스코프의 숨겨진 상태로 클로저를 통해 보존 관리합니다.

# 8.3 Node.js의 CommonJS 모듈

CommonJS 모듈은 앞서 살펴본 IIFE 모듈 정의 방식과 유사하게 싱글턴 인스턴스처럼 작동한다. 동일한 모듈을 몇 번이나 require()로 불러와도 모두 같은 모듈 인스턴스에 대한 참조를 얻는다.

# 8.4 최신 ES. 모듈

ES 모듈은 파일 상단에 전처리 구문 `use strict` 가 없어도 엄격 모드로 실행된다. require() 대신 import 키워드를 사용한다.

# 8.5 정리

렉시컬 스코프 규칙을 사용해 변수와 함수를 적절한 위치에 배치하는 방법을 배워 모듈 패턴을 효율적으로 사용하는 것이 이 책의 결론이자 여정의 끝이다.

모듈 아래에서 클로저는 렉시컬 스코프 시스템을 활용해 모듈 상태를 유지하는 역할을 한다.
