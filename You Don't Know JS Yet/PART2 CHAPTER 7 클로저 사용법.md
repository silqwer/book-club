- 클로저는 변수를 오랫동안 유지해야 할 때 사용된다.
- 외부 스코프 대신 제한된 스코프로 변수를 캡슐화할 수 있다.
- 함수 내부에서 함수 밖 변수를 계속 사용할 수 있는 장점이 있다.
- 이는 함수가 클로저를 통해 참조된 스코프 변수를 기억하기 때문이다.
- 클로저는 함수형 프로그래밍, 모듈, 클래스 지향 설계 등 패러다임의 근간이다.

# 7.1 클로저 관찰하기

- 클로저는 함수에서만 일어나는 함수 동작이다.
- 클로저를 관찰하려면 함수를 반드시 호출해야 한다.

클로저는 외부 스코프가 종료된 후에도 greetStudent()가 외부 변수에 계쏙 접근할 수 있게 해준다. 즉 lookupStudent()의 각 호출이 완료된 후에도 studuents와 studentID의 인스턴스가 가비지 컬렉터의 대상이 되지 않고 메모리에 유지된다는 말이다

## 7.1.1 화살표 함수의 스코프

```tsx
var student = students.find(
  (student) =>
    // 함수 스코프: 주황색 버블 ④
    student.id == studentID
);
```

중요한 점은 작은 화살표 함수조차 클로저를 형성할 수 있다는 점이다.

## 7.1.2 추가되는 클로저

클로저는 단순히 함수의 코드에 의해 정의(단일 렉시컬 정의) 되는게 아니라 함수 인스턴스에 따라 다르게 생성된다.

외부 함수 adder()가 실행될 때마다 내부 함수 addTo()의 새로운 인스턴스가 생성되고, 새로운 인스턴스에는 새로운 클로저가 생성된다.

클로저는 렉시컬 스코프에 기반을 두고 있고 컴파일 시 처리되긴 하지만, 실제로 클로저의 동작은 실행 시점에 함수 인스턴스에 따라 달라지는 특성이라 생각하면 된다.

## 7.1.3 스냅숏이 아닌 라이브 링크

클로저는 실시간으로 변수 자체에 언제든 접근할 수 있도록 관계를 맺어주는 라이브 링크이다.

클로저를 통해 값을 읽는 것뿐만 아니라 수정(재할당)할 수 있다.

함수로 변수를 감사서 가꿨기 때문에 프로그램에서 함수 참조가 존재하는 한 언제든 해당 변수를 읽고 쓰는 게 가능하다.

클로저의 외부 스코프는 일반적으로 함수에서 유래하지만, 반드시 함수 스코프일 필요는 없다. 내부 함수를 감싸는 외부 스코프가 존재하기만 해도 클로저가 된다.

## 7.1.4 쉽게 관찰할 수 있는 클로저: Ajax와 이벤트

클로저는 콜백을 다룰 때 흔히 관찰할 수 있다.

## 7.1.5 보이지 않으면 어떡하죠?

> 아무도 없는 숲에서 나무 한 그루가 쓰러졌지만, 그 누구도 소리를 듣지 못했다면 소리는 난 것인가?

클로저를 형성할 수 있었지 실제로는 호출되지 않았기 때문에 클로저가 활용되지 않았다.

## 7.1.6 관찰 가능성 관점에서 클로저 정의

> 클로저는 함수가 외부 스코프의 변수를 사용하면서, 그 변수에 접근 가능하지 않은 다른 스코프에서 실행될 때 관찰된다.

- 반드시 함수와 관련되어야 한다.
- 외부 스코프의 변수를 적어도 하나 이상 참조해야 한다.
- 참조하려는 변수가 있는 스코프 체인의 다른 분기에서 함수를 호출해야 한다.

# 7.2 클로저 생명주기와 가비지 컬랙션

클로저는 본질적으로 함수의 인스턴스와 연결되므로 이 함수를 참조하는 함수가 있는 한 변수에 대한 클로저는 지속된다.

클로저의 특성은 효율적이고 성능이 뛰어난 프로그램을 구축하는 데 큰 영향을 준다.

클로저는 변수의 GC를 예기치 않게 막아 메모리 사용을 급증시키는 요인이 될 수 있다.

더 이상 필요하지 않은 함수 참조(그리고 그에 따른 클로저)는 제때 삭제하는 게 중요하다.

프로그램의 전반적인 상태와 효율성을 고려할 때 이벤트 핸들러가 더 이상 필요하지 않을 때 구독을 취소하는 것이 첫 번째 구독보다 훨씬 더 중요하다.

## 7.2.1 변수 혹은 스코프

개념만 따졌을 때 클로저는 변수를 기준으로 작동하며 스코프를 기준으로 작동하지 않는다.

다른 모든 형태의 함수에 형성되는 클로저는 일반적으로 명시적으로 참조하는 것에 대해서만 형성도니다고 가정한다.

클로저는 구현 측면에서 스코프 단위로 이뤄진다. 클로저는 함수가 정의된 스코프 전체를 포함할 수 있고 이는 함수가 외부 스코프의 모든 변수에 접근할 수 있음을 의미한다.

객체나 배열처럼 큰 값을 가진 변수가 있고 해당 변수가 클로저 스코프에 있는 경우, 해당 값이 더 이상 필요하지 않고 메모리도 필요하지 않다면 메모리 사용량 측면에서 수동으로 값을 버리는 쪽이 안전한다. 클로저 최적화나 GC에 의존하지 마라.

개발자는 필요 이상으로 메모리를 점유하지 않도록 주의하면서 명시적으로 값을 해제하는 등의 습관을 들이는 게 좋다.

# 7.3 다른 관점

새로운 관점으로 클로저를 정의하면 클로저는 프로그램의 다른 부분에서 해당 함수 인스턴스에 대한 참조가 존재하는 한 함수 인스턴스와 그 전체 스코프 환경 및 스코프 체인을 살아 있게 유지하는 마법이라고 할 수 있다.

# 7.4 클로저를 사용하는 이유

클로저를 기반으로 하는 함수형 프로그래밍 패러다임의 대표적인 기법 두 가지는 적용과 커링이다.

클로저를 통해 내부에 정보를 캡슐화하는 함수 인스턴스를 만들면 나중에 입력을 다시 제공할 필요 없이, 정보를 저장한 함수를 다시 사용할 수 있다.

- 명확한 코드 작성
- 의미 있는 네이밍

# 7.5 정리

- 관찰 관점: 클로저는 함수가 다른 스코프로 전달되거나 호출될 때에도 회부 변수를 기억하는 함수 인스턴스이다.
- 구현 관점: 클로저는 다른 스코프에서 참조가 전달되고 호출되는 동안 함수 인스턴스와 해당 스코프 환경을 제자리에 보존한다.

## 클로저 사용 이점

- 함수 인스턴스가 매번 계산할 필요 없이 이전에 결정된 정보를 기억해내어 함수의 효율성을 높인다.
- 함수 인스턴스 안에 변수를 캡슐화해 코드 가독성을 개선하고 스코프 노출을 제한하는 동시에 나중에 변수에 있는 정보를 사용할 수 있도록 보장한다. 함수를 호출할 때마다 정보를 전달할 필요가 없으므로 작게 전문화된 함수 인스턴스는 상호작용하기가 더 쉬워진다.
