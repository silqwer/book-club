# 4.1 첫 번째 기둥: 스코프와 클로저

JS만의 독특한 특징

1. 호이스팅
   1. 특정 스코프 내에 선언한 변수가 선언된 위치와 상관없이 해당 스코프 시작 부분에서 선언한 것마냥 끌어올려지는 것 처럼 처리
2. `var`를 사용해 선언한 변수는 해당 변수를 선언한 블록 위치와 상고나없이 함수 기준으로 스코코가 만들어진다.

클로저

바깥 스코프에 있는 변수를 참조하는 함수가 있고, 이 함수가 변수를 통해 별개의 스코프에서 실행될 대, 함수는 함수가 정의된 스코프를 기준으로 변수를 참조한다. 이게 클로저이다.

# 4.2 두 번째 기둥: 프로토타입

JS를 지탱하는 두 번째 기둥은 프로토타입 시스템이다.

저자는 클래스로 관심사가 이동하면서 프로토타입 시스템의 아름다움과 힘이 흐려진 상태라고 생각한다.

프로토타입을 사용하면 `this` 컨텍스트가 공유되면서 두 객체를 아주 간편하게 연결할 수 있고 함수나 메서드가 실행되는 동안 두 객체를 동적으로 협력할 수 있다고 말한다.

객체는 객체로서 그대로 두고, 클래스 없이 프로토타입 체인을 통해 객체가 협력하도록 하는 전혀 다른 방식의 접근 법도 있는데 이 접근법을 작동 위임 패턴이라고 한다.

저자는 코드 동작과 데이터를 구조화하는 데 있어서 작동 위힘 패턴이 클래스 상속보다 더 강력하다고 생각한다.

# 4.3 세 번째 기능: 타입과 타입 강제 변환

JS를 지탱하는 세 번째 기둥은 타입과 타입 강제 변환이다.

저자는 JS 타입 메커니즘의 단점 때문에 해결책을 언더 밖에서 찾을 수밖에 없다는 결론에는 동의할 수 없다고 말한다. → JS 단독으로 할 수는 있는데 너무 복잡하고 손이 너무 많이 가자나…

타입과 타입 강제 변환이 바로 서 있지 않으면 아무리 열심히 학습해도 기반이 흔들리고 불완전하다.

# 4.4 JS의 본질 따르기

저자의 주장을 그대로 차용해서 쓰려면 왜 그렇게 생각하는지 답변할 준비가 되어있어야 한다.

→ 그대로 사용할 생각이 없음

JS를 학습할 때는 가독성 향상에 도움을 주는 방식이 있는지 항상 탐구해야 한다. 이렇게 하다 보면 미래의 자신을 포함해서 같이 작업하게 될 사람들의 감사 인사를 저절로 받게 될 것이다.

# 4.5 학습 순서

상황에 따라 다르다.
