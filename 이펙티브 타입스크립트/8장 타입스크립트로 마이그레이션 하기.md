# 아이템 58 모던 자바스크립트로 작성하기

## ECMAScript 모듈 사용하기

단일 파일이거나 비표준 모듈 시스템을 사용 중이라면 ES 모듈로 전환하는 것이 좋다.

## 프로토타입 대신 클래스 사용하기

문법이 간결하고 직관적이다.

편집기에서 프로토타입 객체에 마우스를 올려, 타입스크립트 언어 서비스인 `Convert function to an ES2015 class` 선택하면 간단히 변환할 수 있다.

## var 대신 let/const 사용하기

→ 이젠 var 사용하는 곳은 없을 듯

## for(;;) 대신 for-of 또는 배열 매서드 사용하기

`for-in` 문법도 존재하지만 몇 가지 문제점이 있기 때문에 사용하지 않는 것이 좋다. → 아이템 16 참고

## 함수 표현식보다 화살표 함수 사용하기

`this` 키워드는 일반적인 변수들과 다른 스코프 규칙을 가지기 때문에, 자바스크립트에서 가장 어려운 개념 중 하나이다.

일반 함수보다 화살표 함수가 더 직관적이며 코드도 간결해지기 때문에 가급적 화살표 함수를 사용하는 것이 좋다.

## 단축 객체 표현과 구조 분해 할당 사용하기

더 간결하고 중복된 이름을 생각하기 때문에 가독성이 좋고 실수가 적다.

구조 분해 문법 내에서 기본값을 지정할 수 있다.

객체 구조 분해를 사용하면 문법이 간결해지고 변수를 사용할 때 실수를 줄일 수 있기 때문에 적극적으로 사용하는 것이 좋다.

## 함수 매개변수 기본값 사용하기

모던 자바스크립트에서는 매개변수에 기본값을 직접 지정할 수 있다.

## 저수준 프로미스나 콜백 대신 async/await 사용하기

코드가 간결해져서 버그나 실수를 방지할 수 있고, 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.

## 연관 배열에 객체 대신 Map과 Set 사용하기

## 타입스크립트에 use strict 넣지 않기

→ 넣을 생각도 안했는데 ..

타입스크립트에서 수행되는 안정성 검사(`sanity check`)가 엄격 모드보다 훨씬 더 엄격한 체크를 하기 때문에, 타입스크립트 코드에서 `‘use strict’` 는 무의미하다.

파이프라인과 데코레이터 기능은 아직 3단계에 이르지 못해지만 큰 잠재력을 지니고 있으므로 조만간 타입스크립트에도 추가될 가능성이 크다.

# 아이템 59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

`@ts-check` 지시자를 사용하면 타입스크립트 전환 시에 어떤 문제가 발생하는지 미리 시험해 볼 수 있다.

`@ts-check` 지시자를 사용하여 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시한다.

`@ts-check` 지시자를 사용하면 타입 불일치나 함수의 매개변수 개수 불일치 같은 간단한 오류 외에도, 아래의 오류를 찾아 낼 수 있다.

## 선언되지 않은 전역변수

어딘가 `숨어있는 변수`라면, 변수를 제대로 인식할 수 있게 별도로 타입 선언 파일을 만들어야 한다.

`declare` : declare는 **TypeScript에게 특정 전역 변수나 외부 모듈, 함수, 클래스가 존재한다고 알리는 데 사용된다**. 컴파일 결과물에는 영향을 미치지 않으며, 런타임에 해당 선언이 실제로 존재하는 것을 전제로 동작한다.

## 알 수 없는 라이브러리

서드파티 라이브러리를 사용하는 경우, 서드 파티 라이브러리의 타입 정보를 알아야 한다.

## DOM 문제

확실히 `dom` 엘리먼트라는 것을 알고 있다면 타입 단언문을 사용해야 한다. `js` 이기 때문에 `JSDoc`을 사용하여 타입 단언을 대체할 수 있다. → 이런 기능이 있었다니?

## 부정확한 JSDoc

`@ts-check` 지시자와 `JSDoc` 주석을 너무 장기간 사용하는 것은 좋지 않다. 주석이 코드 분량을 늘려서 로직을 해석하는 데 방해가 될 수 있기 때문이다.

# 아이템 60 allowjs로 타입스트립트와 자바스크립트같이 사용하기

마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있도록 해야한다. → 타이피스트 생각!

`allowJs` 컴파일러 옵션은 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다. → 타이피스트에서 이런 옵션을 사용했나?

# 아이템 61 의존성 관계에 따라 모듈 단위로 전환하기

모듈 단위로 각개격파 하는 것이 이상적이다.

다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야한다.

서드파티 라이브러리 타입 정보를 가장 먼저 해결해야 한다. 일반적으로 `@types` 모듈을 설치하면 된다.

madge라는 도구를 적용하면 의존성 관계도를 얻게 된다.

마이그레이션 할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안 된다.

오래된 프로젝트일수록 개선이 필요한 부분을 자주 마주치겠지만, 당장의 목표는 코드 개선이 아니라 타입스크립트로 전환하는 것임을 명심해야 한다.

개선이 필요한 부분을 찾게 된다면 나중에 리팩터링할 수 있도록 목록을 만들어 두면 된다.

## 선언되지 않는 클래스 멤버

빠른 수정 기능으로 간단히 해결할 수 있다.

자바스크립트 코드를 타입스크립트로 전환하다 보면, 잘못된 설계를 발견하는 효과가 있다.

## 타입이 바뀌는 값

당장 마이그레이션이 중요하기 때문에 타입 단언문을 사용한다.

마지막 단계로, 테스트 코드를 타입스크립트로 전환하면 된다.

마이그레이션 기간 중에 테스트를 수행할 수 있다는 것은 엄청난 이점이다.

# 아이템 62 마이그레이션의 완성을 위해 `noImplicitAny` 설정하기

`noImplicitAny` 설정을 하지 않으면, 타입 체크는 매우 허술해진다.

처음에는 `noImplicitAny`를 로컬에만 설정하고 작업하는 것이 좋다.

로컬에서만 오류로 인식되기 때문에, 수정된 부분만 커밋할 수 있어서 점진적 마이그레이션이 가능하다.

최종적으로 가장 강력한 설정은 `“strict”: true` 이다. 타입 체크의 강도는 팀 내의 모든 사람이 타입스크립트에 익숙해진 다음에 조금씩 높이는 것이 좋다.
